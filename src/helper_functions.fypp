!-------------------------------------------------------------------------
! This file is part of the tenstream solver.
!
! This program is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.
!
! Copyright (C) 2010-2015  Fabian Jakub, <fabian@jakub.com>
!-------------------------------------------------------------------------

! FyPP Rank suffix generator to template over scalar an N-d functions
#:def ranksuffix(RANK)
$:'' if RANK == 0 else '(' + ':' + ',:' * (RANK - 1) + ')'
#:enddef ranksuffix

#:def rankallocdims(RANK)
$:'' if RANK == 0 else '('+','.join(['Ntot({})'.format(_) for _ in range(1,RANK+1)]) + ')'
#:enddef rankallocdims

module m_helper_functions
  use iso_fortran_env, only: INT32, INT64, REAL32, REAL64, REAL128
  use m_data_parameters,only : iintegers, mpiint, &
    ireals, irealLUT, ireal_dp, &
    i1, pi, pi32, pi64, pi128, zero, one, nan, &
    imp_ireals, imp_logical, &
    imp_REAL32, imp_REAL64, &
    default_str_len, &
    imp_int4, imp_int8, imp_iinteger

#include "petsc/finclude/petsc.h"
  use petsc
  use mpi

  implicit none

  private
  public &
    & angle_between_two_normed_vec, &
    & angle_between_two_vec, &
    & approx, &
    & assert_arr_is_monotonous, &
    & assertEqual, &
    & char_arr_to_str, &
    & char_to_lower, &
    & char_to_upper, &
    & CHKERR, &
    & CHKWARN, &
    & colored_str_by_range, &
    & compute_normal_3d, &
    & cross_2d, &
    & cross_3d, &
    & cstr, &
    & cumprod, &
    & cumsum, &
    & deallocate_allocatable, &
    & deg2rad, &
    & delta_scale, &
    & delta_scale_optprop, &
    & determine_normal_direction, &
    & distance, &
    & distances_to_triangle_edges, &
    & distance_to_edge, &
    & domain_decompose_2d, &
    & domain_decompose_2d_petsc, &
    & ftoa, &
    & get_arg, &
    & get_mem_footprint, &
    & gradient, &
    & imp_allgather_int_inplace, &
    & imp_allreduce_max, &
    & imp_allreduce_mean, &
    & imp_allreduce_min, &
    & imp_allreduce_sum, &
    & imp_bcast, &
    & imp_min_mean_max, &
    & imp_reduce_mean, &
    & imp_reduce_sum, &
    & inc, &
    & ind_1d_to_nd, &
    & ind_nd_to_1d, &
    & is_between, &
    & is_inrange, &
    & itoa, &
    & linspace, &
    & ltoa, &
    & meanval, &
    & meanvec, &
    & mpi_logical_all_same, &
    & mpi_logical_and, &
    & mpi_logical_or, &
    & ndarray_offsets, &
    & normalize_vec, &
    & rad2deg, &
    & read_ascii_file_2d, &
    & rel_approx, &
    & reorder_mpi_comm, &
    & resize_arr, &
    & reverse, &
    & rmse, &
    & rotate_angle_x, &
    & rotate_angle_y, &
    & rotate_angle_z, &
    & rotation_matrix_around_axis_vec, &
    & rotation_matrix_local_basis_to_world, &
    & rotation_matrix_world_to_local_basis, &
    & sEXP, &
    & solve_quadratic, &
    & cartesian_2_spherical, &
    & spherical_2_cartesian, &
    & strF2C, &
    & swap, &
    & toStr, &
    & transposed_arr, &
    & triangle_area_by_edgelengths, &
    & triangle_area_by_vertices, &
    & triangle_inner_circle_center, &
    & unique, &
    & vec_proj_on_plane

  interface rotate_angle_x
#:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure rotate_angle_x_${dtype}$
#:endfor
  end interface
  interface rotate_angle_y
#:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure rotate_angle_y_${dtype}$
#:endfor
  end interface
  interface rotate_angle_z
#:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure rotate_angle_z_${dtype}$
#:endfor
  end interface

  interface rmse
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure rmse_${dtype}$
    #:endfor
  end interface
  interface vec_proj_on_plane
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure vec_proj_on_plane_${dtype}$
    #:endfor
  end interface
  interface cartesian_2_spherical
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure cartesian_2_spherical_${dtype}$
    #:endfor
  end interface
  interface spherical_2_cartesian
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure spherical_2_cartesian_${dtype}$
    #:endfor
  end interface
  interface rad2deg
    module procedure rad2deg_r32, rad2deg_r64, rad2deg_r128
  end interface
  interface deg2rad
    module procedure deg2rad_r32, deg2rad_r64, deg2rad_r128
  end interface
  interface approx
    module procedure approx_r32, approx_r64, approx_r128
  end interface
  interface distance
#:for dtype in ['REAL32', 'REAL64']
    module procedure distance_${dtype}$
#:endfor
  end interface

  interface toStr
    module procedure ltoa
    #:for basetype,dtype in [&
      ('integer', 'INT32'  ), &
      ('integer', 'INT64'  ), &
      ('real'   , 'REAL32' ), &
      ('real'   , 'REAL64' ), &
      ('real'   , 'REAL128')]
      module procedure toStr${dtype}$
      #:for RANK in range(1, 8)
        module procedure toStr${dtype}$_${RANK}$d
      #:endfor
    #:endfor
  end interface

  interface itoa
    #:for dtype in ['INT32', 'INT64']
      module procedure toStr${dtype}$
      #:for RANK in range(1, 8)
        module procedure toStr${dtype}$_${RANK}$d
      #:endfor
    #:endfor
  end interface

  interface ftoa
   #:for dtype in ['REAL32', 'REAL64', 'REAL128']
     module procedure toStr${dtype}$
     #:for RANK in range(1, 8)
       module procedure toStr${dtype}$_${RANK}$d
     #:endfor
   #:endfor
  end interface

  interface meanval
    #:for intype,dtype,otype in [ &
      ('integer', 'INT32'  ,'ireals'), &
      ('integer', 'INT64'  ,'ireals'), &
      ('real'   , 'REAL32' ,'REAL32'), &
      ('real'   , 'REAL64' ,'REAL64'), &
      ('real'   , 'REAL128','REAL128')]
    #:for RANK in range(1, 8)
    module procedure meanval_intype_${intype}$_${dtype}$_${RANK}$d_out${otype}$
    #:endfor
    #:endfor
  end interface

  interface imp_allreduce_mean
    module procedure imp_allreduce_mean_0d
#:for RANK in range(1, 4)
    module procedure imp_allreduce_mean_${RANK}$d
#:endfor
  end interface
  interface imp_allreduce_sum
    module procedure imp_allreduce_sum_ireals, imp_allreduce_sum_i32, imp_allreduce_sum_i64
  end interface
  interface imp_allreduce_min
    module procedure imp_allreduce_min_ireals, imp_allreduce_min_iintegers
  end interface
  interface imp_allreduce_max
    module procedure imp_allreduce_max_ireals, imp_allreduce_max_iintegers
  end interface
  interface imp_reduce_sum
    module procedure imp_reduce_sum_r32, imp_reduce_sum_r64, imp_reduce_sum_r128
  end interface

  interface imp_reduce_mean
#:for method,dtype,mpitype,otype in [ &
  ('integer', 'INT32' , 'imp_int4'  , 'ireals'), &
  ('integer', 'INT64' , 'imp_int8'  , 'ireals'), &
  ('real'   , 'REAL32', 'imp_REAL32', 'REAL32'), &
  ('real'   , 'REAL64', 'imp_REAL64', 'REAL64')]
#:for RANK in range(1, 8)
    module procedure imp_reduce_mean_${method}$_${dtype}$_${RANK}$d_${otype}$
#:endfor
#:endfor
  end interface

  interface imp_min_mean_max
#:for method,dtype,mpitype,otype in [ &
  ('integer', 'INT32' , 'imp_int4'  , 'ireals'), &
  ('integer', 'INT64' , 'imp_int8'  , 'ireals'), &
  ('real'   , 'REAL32', 'imp_REAL32', 'REAL32'), &
  ('real'   , 'REAL64', 'imp_REAL64', 'REAL64')]
#:for RANK in range(0, 8)
    module procedure imp_min_mean_max_${method}$_${dtype}$_${RANK}$d_${otype}$
#:endfor
#:endfor
  end interface

  interface imp_bcast
#:for method,dtype,mpitype in [ &
  ('logical', ''      , 'imp_logical'), &
  ('integer', 'INT32' , 'imp_int4')   , &
  ('integer', 'INT64' , 'imp_int8')   , &
  ('real'   , 'REAL32', 'imp_REAL32') , &
  ('real'   , 'REAL64', 'imp_REAL64')]
#:for RANK in range(0, 8)
#:for modifier in [None, 'allocatable', 'pointer']
#:if (modifier is None and (RANK==0)) or (modifier is not None and (RANK>0))
    module procedure imp_bcast_${method}$_${dtype}$_${RANK}$d_${modifier}$
#:endif
#:endfor
#:endfor
#:endfor
  end interface

  interface get_arg
    module procedure get_arg_logical, get_arg_i32, get_arg_i64, get_arg_real32, get_arg_real64, get_arg_char
  end interface
  interface sEXP
    module procedure sEXP_r32, sEXP_r64
  end interface
  interface swap
    #:for basetype, dtype, ctype in [&
      ('integer', 'INT32'  ), &
      ('integer', 'INT64'  ), &
      ('real'   , 'REAL32' ), &
      ('real'   , 'REAL64' ), &
      ('real'   , 'REAL128')]
    module procedure swap_${dtype}$
    #:endfor
  end interface
  interface transposed_arr
    module procedure transposed_arr_3d_ireals
  end interface
  interface cumsum
    module procedure cumsum_iintegers, cumsum_ireals
  end interface
  interface cumprod
    module procedure cumprod_i32, cumprod_i64, cumprod_ireals
  end interface
  interface resize_arr
    module procedure resize_arr_1d_int32, resize_arr_1d_int64, &
      resize_arr_2d_r32, resize_arr_2d_r64, &
      resize_arr_3d_r32, resize_arr_3d_r64
  end interface
  interface reverse
    module procedure reverse_1d_real32, reverse_2d_real32, reverse_1d_real64, reverse_2d_real64, &
        reverse_3d_real32, reverse_3d_real64, reverse_4d_real32, reverse_4d_real64
  end interface
  interface is_between
#:for dtype in ['INT32', 'INT64', 'REAL32', 'REAL64', 'REAL128']
    module procedure is_between_${dtype}$
#:endfor
  end interface
  interface is_inrange
#:for dtype in ['INT32', 'INT64', 'REAL32', 'REAL64', 'REAL128']
    module procedure is_inrange_${dtype}$
#:endfor
  end interface
  interface assertEqual
    #:for dtype in ['INT32', 'INT64']
    module procedure assertEqual_${dtype}$, assertEqual_${dtype}$_with_msg
    #:endfor
  end interface

  interface cross_2d
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure cross_2d_${dtype}$
    #:endfor
  end interface
  interface cross_3d
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure cross_3d_${dtype}$
    #:endfor
  end interface
  interface angle_between_two_vec
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure angle_between_two_vec_${dtype}$
    #:endfor
  end interface
  interface angle_between_two_normed_vec
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure angle_between_two_normed_vec_${dtype}$
    #:endfor
  end interface
  interface compute_normal_3d
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure compute_normal_3d_${dtype}$
    #:endfor
  end interface
  interface normalize_vec
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure normalize_vec_${dtype}$
    module procedure normalize_vec_inplace_${dtype}$
    #:endfor
  end interface

  interface rotation_matrix_around_axis_vec
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure rotation_matrix_around_axis_vec_${dtype}$
    #:endfor
  end interface

  interface rotation_matrix_local_basis_to_world
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure rotation_matrix_local_basis_to_world_${dtype}$
    #:endfor
  end interface

  interface determine_normal_direction
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure determine_normal_direction_${dtype}$
    #:endfor
  end interface

  interface distances_to_triangle_edges
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure distances_to_triangle_edges_${dtype}$
    #:endfor
  end interface

  interface distance_to_edge
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure distance_to_edge_${dtype}$
    #:endfor
  end interface

  interface triangle_area_by_vertices
#:for dtype in ['REAL32', 'REAL64']
    module procedure triangle_area_by_vertices_${dtype}$
#:endfor
  end interface
  interface triangle_area_by_edgelengths
#:for dtype in ['REAL32', 'REAL64']
    module procedure triangle_area_by_edgelengths_${dtype}$
#:endfor
  end interface
  interface triangle_inner_circle_center
#:for dtype in ['REAL32', 'REAL64']
    module procedure triangle_inner_circle_center_${dtype}$
#:endfor
  end interface

  interface delta_scale
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure delta_scale_${dtype}$
    #:endfor
  end interface

  interface delta_scale_optprop
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure delta_scale_optprop_${dtype}$
    #:endfor
  end interface

  interface solve_quadratic
    module procedure solve_quadratic_r32, solve_quadratic_r64, solve_quadratic_r128
  end interface

  interface linspace
    module procedure linspace_r32, linspace_r64
  end interface

  interface assert_arr_is_monotonous
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    module procedure assert_arr_is_monotonous_${dtype}$
    #:endfor
  end interface

  interface deallocate_allocatable
    #:for basetype,dtype,destructor in [ &
      ('type'      , 'tVec'   , 'call VecDestroy(obj, ierr); call CHKERR(ierr);'), &
      ('type'      , 'tDM'    , 'call DMDestroy (obj, ierr); call CHKERR(ierr);'), &
      ('type'      , 'tKSP'   , 'call KSPDestroy(obj, ierr); call CHKERR(ierr);'), &
      ('type'      , 'tMat'   , 'call MatDestroy(obj, ierr); call CHKERR(ierr);'), &
      ('type'      , 'tIS'    , 'call ISDestroy (obj, ierr); call CHKERR(ierr);'), &
      ('logical'   , None     , None                                            ), &
      ('integer'   , 'INT32'  , None                                            ), &
      ('integer'   , 'INT64'  , None                                            ), &
      ('real'      , 'REAL32' , None                                            ), &
      ('real'      , 'REAL64' , None                                            )]
    #:set dKIND = '' if dtype == None else '('+dtype+')'
    #:for RANK in range(0, 8)
    #:if not ((destructor is not None) and (RANK>0))
    module procedure deallocate_allocatable_${basetype}$_${dtype}$_${RANK}$d
    #:endif
    #:endfor
    #:endfor
  end interface

  interface colored_str_by_range
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    #:for RANK in range(0, 8)
    module procedure colored_str_by_range${dtype}$_${RANK}$d
    #:endfor
    #:endfor
  end interface

  integer(iintegers), parameter :: npar_cumprod=8

  contains

    function strF2C(str)
      use iso_c_binding, only: C_NULL_CHAR
      character(len=*), intent(in) :: str
      character(len=len_trim(str)+1) :: strF2C
      strF2C = trim(str)//C_NULL_CHAR
    end function

    pure elemental function sEXP_r32(x) result(r)
      real(REAL32),intent(in) :: x
      real(REAL32) :: r
      real(kind(x)), parameter :: exp_maxval=-log(epsilon(exp_maxval))
      r = exp(sign( min(exp_maxval, abs(x)), x))
    end function
    pure elemental function sEXP_r64(x) result(r)
      real(REAL64),intent(in) :: x
      real(REAL64) :: r
      real(kind(x)), parameter :: exp_maxval=-log(epsilon(exp_maxval))
      r = exp(sign( min(exp_maxval, abs(x)), x))
    end function

#:for basetype, dtype, ctype in [&
  ('integer', 'INT32'  ), &
  ('integer', 'INT64'  ), &
  ('real'   , 'REAL32' ), &
  ('real'   , 'REAL64' ), &
  ('real'   , 'REAL128')]
  pure elemental subroutine swap_${dtype}$(x,y)
    ${basetype}$ (${dtype}$),intent(inout) :: x,y
    ${basetype}$ (${dtype}$) :: tmp
    tmp = x; x = y; y = tmp
  end subroutine
#:endfor

    function transposed_arr_3d_ireals(arr) result(trans)
      real(ireals), intent(in) :: arr(:,:,:)
      real(ireals) :: trans(size(arr,dim=3),size(arr,dim=2),size(arr,dim=1))
      trans = reshape(arr, shape(trans), order=[3,2,1])
    end function

    pure elemental subroutine inc(x,i)
      real(ireals),intent(inout) :: x
      real(ireals),intent(in) :: i
      x=x+i
    end subroutine

#:for basetype, dtype, ctype in [&
  ('integer', 'INT32'  , 'REAL64'), &
  ('integer', 'INT64'  , 'REAL64'), &
  ('real'   , 'REAL32' , 'REAL64'), &
  ('real'   , 'REAL64' , 'REAL64'), &
  ('real'   , 'REAL128', 'REAL128')]
    pure elemental logical function is_between_${dtype}$(x,a,b) result(is_between)
      ${basetype}$ (${dtype}$), intent(in) :: x,a,b
      real(${ctype}$) :: r
      r = real(x-a, kind(r)) * real(x-b, kind(r))
      is_between = r .lt. 0._${ctype}$
    end function
    pure elemental logical function is_inrange_${dtype}$(x,a,b) result(is_between)
      ${basetype}$ (${dtype}$), intent(in) :: x,a,b
      real(${ctype}$) :: r
      r = real(x-a, kind(r)) * real(x-b, kind(r))
      is_between = r .le. 0._${ctype}$
    end function
#:endfor

    subroutine CHKERR(ierr, descr)
      integer(mpiint),intent(in) :: ierr
      character(len=*), intent(in), optional :: descr
      integer(mpiint) :: myid, mpierr

      if(ierr.ne.0) then
        call mpi_comm_rank(MPI_COMM_WORLD, myid, mpierr)
        if(present(descr)) then
          print *,itoa(myid)//cstr(' ERROR: '//itoa(ierr)//': '//trim(descr), 'red')
        else
          print *,itoa(myid)//cstr(' ERROR: '//itoa(ierr), 'red')
        endif
#ifdef _GNU
        call BACKTRACE
#elif defined _INTEL
        CALL tracebackqq
#endif
        call mpi_abort(mpi_comm_world, ierr, mpierr)
      endif
    end subroutine

    subroutine CHKWARN(ierr, descr)
      integer(mpiint),intent(in) :: ierr
      character(len=*), intent(in), optional :: descr
      integer(mpiint) :: myid, mpierr

      if(ierr.ne.0) then
        call mpi_comm_rank(MPI_COMM_WORLD, myid, mpierr)
        if(present(descr)) then
          print *,itoa(myid)//cstr(' Warning: '//itoa(ierr)//': '//trim(descr), 'purple')
        else
          print *,itoa(myid)//cstr(' Warning: '//itoa(ierr), 'purple')
        endif
      endif
    end subroutine

    #:for dtype in ['INT32', 'INT64']
    subroutine assertEqual_${dtype}$(t, i)
      integer(${dtype}$),intent(in) :: t, i
      if(t.ne.i) then
          call CHKERR(int(t-i, mpiint), itoa(i)//'.ne.'//itoa(t))
      endif
    end subroutine
    subroutine assertEqual_${dtype}$_with_msg(t, i, msg)
      integer(${dtype}$),intent(in) :: t, i
      character(len=*), intent(in) :: msg
      if(t.ne.i) then
          call CHKERR(int(t-i, mpiint), itoa(i)//'.ne.'//itoa(t)//' :: '//msg)
      endif
    end subroutine
    #:endfor

    elemental function ltoa(l) result(res)
      character(len=1) :: res
      logical,intent(in) :: l
      if(l) then
        res = 'T'
      else
        res = 'F'
      endif
    end function

    #:for basetype, dtype, fmt in [&
      ('integer', 'INT32'  , "'(I0)'"), &
      ('integer', 'INT64'  , "'(I0)'"), &
      ('real'   , 'REAL32' , "'(F16.7)'"), &
      ('real'   , 'REAL64' , "'(F16.7)'"), &
      ('real'   , 'REAL128', "'(F16.7)'")]
    function toStr${dtype}$(inp) result (res)
      ${basetype}$(${dtype}$), intent(in) :: inp
      character(len=:), allocatable :: res
      character(range(inp)+2) :: tmp
      write(tmp,fmt=${fmt}$) inp
      res = trim(tmp)
    end function

    #:for RANK in range(1, 8)
    function toStr${dtype}$_${RANK}$d(inp, deliminator) result (res)
      ${basetype}$(${dtype}$), intent(in) :: inp${ranksuffix(RANK)}$
      character(len=:), allocatable :: res
      character(len=*), intent(in), optional :: deliminator
      character(range(inp)+2) :: tmp(size(inp))
      ${basetype}$(${dtype}$), allocatable :: inp1d(:)
      integer(iintegers) :: i
      inp1d = pack(inp, .True.)
      do i=1,size(inp1d)
        tmp(i) = toStr(inp1d(i))
      enddo
      res = trim(char_arr_to_str(tmp, deliminator))
    end function
    #:endfor
    #:endfor



    pure function gradient(v)
      real(ireals),intent(in) :: v(:)
      real(ireals) :: gradient(size(v)-1)
      gradient = v(2:size(v))-v(1:size(v)-1)
    end function

    pure function meanvec(v)
      real(ireals),intent(in) :: v(:)
      real(ireals) :: meanvec(size(v)-1)
      meanvec = (v(2:size(v))+v(1:size(v)-1))*.5_ireals
    end function

    !> @brief Cross product, right hand rule, a(thumb), b(pointing finger)
    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    pure function cross_3d_${dtype}$(a, b) result(cross_3d)
      real(${dtype}$), dimension(3), intent(in) :: a, b
      real(${dtype}$), dimension(3) :: cross_3d

      cross_3d(1) = a(2) * b(3) - a(3) * b(2)
      cross_3d(2) = a(3) * b(1) - a(1) * b(3)
      cross_3d(3) = a(1) * b(2) - a(2) * b(1)
    end function
    pure function cross_2d_${dtype}$(a, b) result(cross_2d)
      real(${dtype}$), dimension(2), intent(in) :: a, b
      real(${dtype}$) :: cross_2d

      cross_2d = a(1) * b(2) - a(2) * b(1)
    end function
    #:endfor

    subroutine resize_arr_3d_r32(N, arr, dim, fillval, lrepeat)
      integer(iintegers), intent(in) :: N
      real(REAL32), allocatable, intent(inout) :: arr(:,:,:)
      integer(mpiint), intent(in), optional :: dim
      real(kind(arr)), intent(in), optional :: fillval
      logical, intent(in), optional :: lrepeat

      real(kind(arr)), allocatable :: tmp(:,:,:)
      integer(kind(N)) :: sdim, i ,j
      integer(mpiint) :: idim
      logical :: repeat_dim

      idim = get_arg(1_mpiint, dim)
      if(idim.gt.size(shape(arr))) &
        call CHKERR(idim, 'requested resize dimension is larger than max dimension of inp array')
      sdim = size(arr, dim=idim)
      if(sdim.eq.N) return

      select case(idim)
      case(1)
        allocate(tmp(N,size(arr,dim=2),size(arr,dim=3))) !**
      case(2)
        allocate(tmp(size(arr,dim=1),N,size(arr,dim=3))) !**
      case(3)
        allocate(tmp(size(arr,dim=1),size(arr,dim=2),N)) !**
      end select

      if(N.lt.sdim) then ! shrinking
        if(present(fillval)) call CHKERR(1_mpiint, 'resize_arr is about to shrink the input arr ' // &
          'but you provided a fillVal - this does not make sense')
        select case(idim)
        case(1)
          tmp(1:N,:,:) = arr(1:N,:,:) !**
        case(2)
          tmp(:,1:N,:) = arr(:,1:N,:) !**
        case(3)
          tmp(:,:,1:N) = arr(:,:,1:N) !**
        end select
      else
        repeat_dim = get_arg(.False., lrepeat)
        if(repeat_dim) then
          if(modulo(N,sdim).ne.0) &
            call CHKERR(1_mpiint, 'resize_arr cannot repeat the dimension('//itoa(idim)// &
            'because '//itoa(N)//' is does not a multiple of inp array size '//itoa(sdim))
          do i=1,N
            j = modulo(i-1,sdim)
            select case(idim)
            case(1)
              tmp(i,:,:) = arr(1+j,:,:) !**
            case(2)
              tmp(:,i,:) = arr(:,1+j,:) !**
            case(3)
              tmp(:,:,i) = arr(:,:,1+j) !**
            end select
          enddo
        else
          if(.not.present(fillVal)) call CHKERR(1_mpiint, 'fillVal is not present but needs to be given here')
          select case(idim)
          case(1)
            tmp(1:sdim,:,:) = arr(1:sdim,:,:) !**
            tmp(sdim+1:N,:,:) = fillVal !**
          case(2)
            tmp(:,1:sdim,:) = arr(:,1:sdim,:) !**
            tmp(:,sdim+1:N,:) = fillVal !**
          case(3)
            tmp(:,:,1:sdim) = arr(:,:,1:sdim) !**
            tmp(:,:,sdim+1:N) = fillVal !**
          end select
        endif
      endif
      call move_alloc(tmp, arr)
    end subroutine
    subroutine resize_arr_3d_r64(N, arr, dim, fillval, lrepeat)
      integer(iintegers), intent(in) :: N
      real(REAL64), allocatable, intent(inout) :: arr(:,:,:)
      integer(mpiint), intent(in), optional :: dim
      real(kind(arr)), intent(in), optional :: fillval
      logical, intent(in), optional :: lrepeat

      real(kind(arr)), allocatable :: tmp(:,:,:)
      integer(kind(N)) :: sdim, i ,j
      integer(mpiint) :: idim
      logical :: repeat_dim

      idim = get_arg(1_mpiint, dim)
      if(idim.gt.size(shape(arr))) &
        call CHKERR(idim, 'requested resize dimension is larger than max dimension of inp array')
      sdim = size(arr, dim=idim)
      if(sdim.eq.N) return

      select case(idim)
      case(1)
        allocate(tmp(N,size(arr,dim=2),size(arr,dim=3))) !**
      case(2)
        allocate(tmp(size(arr,dim=1),N,size(arr,dim=3))) !**
      case(3)
        allocate(tmp(size(arr,dim=1),size(arr,dim=2),N)) !**
      end select

      if(N.lt.sdim) then ! shrinking
        if(present(fillval)) call CHKERR(1_mpiint, 'resize_arr is about to shrink the input arr ' // &
          'but you provided a fillVal - this does not make sense')
        select case(idim)
        case(1)
          tmp(1:N,:,:) = arr(1:N,:,:) !**
        case(2)
          tmp(:,1:N,:) = arr(:,1:N,:) !**
        case(3)
          tmp(:,:,1:N) = arr(:,:,1:N) !**
        end select
      else
        repeat_dim = get_arg(.False., lrepeat)
        if(repeat_dim) then
          if(modulo(N,sdim).ne.0) &
            call CHKERR(1_mpiint, 'resize_arr cannot repeat the dimension('//itoa(idim)// &
            'because '//itoa(N)//' is does not a multiple of inp array size '//itoa(sdim))
          do i=1,N
            j = modulo(i-1,sdim)
            select case(idim)
            case(1)
              tmp(i,:,:) = arr(1+j,:,:) !**
            case(2)
              tmp(:,i,:) = arr(:,1+j,:) !**
            case(3)
              tmp(:,:,i) = arr(:,:,1+j) !**
            end select
          enddo
        else
          if(.not.present(fillVal)) call CHKERR(1_mpiint, 'fillVal is not present but needs to be given here')
          select case(idim)
          case(1)
            tmp(1:sdim,:,:) = arr(1:sdim,:,:) !**
            tmp(sdim+1:N,:,:) = fillVal !**
          case(2)
            tmp(:,1:sdim,:) = arr(:,1:sdim,:) !**
            tmp(:,sdim+1:N,:) = fillVal !**
          case(3)
            tmp(:,:,1:sdim) = arr(:,:,1:sdim) !**
            tmp(:,:,sdim+1:N) = fillVal !**
          end select
        endif
      endif
      call move_alloc(tmp, arr)
    end subroutine
    subroutine resize_arr_2d_r32(N, arr, dim, fillval, lrepeat)
      integer(iintegers), intent(in) :: N
      real(REAL32), allocatable, intent(inout) :: arr(:,:)
      integer(mpiint), intent(in), optional :: dim
      real(kind(arr)), intent(in), optional :: fillval
      logical, intent(in), optional :: lrepeat

      real(kind(arr)), allocatable :: tmp(:,:)
      integer(kind(N)) :: sdim, i ,j
      integer(mpiint) :: idim
      logical :: repeat_dim

      idim = get_arg(1_mpiint, dim)
      if(idim.gt.size(shape(arr))) &
        call CHKERR(idim, 'requested resize dimension is larger than max dimension of inp array')
      sdim = size(arr, dim=idim)
      if(sdim.eq.N) return

      select case(idim)
      case(1)
        allocate(tmp(N,size(arr,dim=2))) !**
      case(2)
        allocate(tmp(size(arr,dim=1),N)) !**
      end select

      if(N.lt.sdim) then ! shrinking
        if(present(fillval)) call CHKERR(1_mpiint, 'resize_arr is about to shrink the input arr ' // &
          'but you provided a fillVal - this does not make sense')
        select case(idim)
        case(1)
          tmp(1:N,:) = arr(1:N,:) !**
        case(2)
          tmp(:,1:N) = arr(:,1:N) !**
        end select
      else
        repeat_dim = get_arg(.False., lrepeat)
        if(repeat_dim) then
          if(modulo(N,sdim).ne.0) &
            call CHKERR(1_mpiint, 'resize_arr cannot repeat the dimension('//itoa(idim)// &
            'because '//itoa(N)//' is does not a multiple of inp array size '//itoa(sdim))
          do i=1,N
            j = modulo(i-1,sdim)
            select case(idim)
            case(1)
              tmp(i,:) = arr(1+j,:) !**
            case(2)
              tmp(:,i) = arr(:,1+j) !**
            end select
          enddo
        else
          if(.not.present(fillVal)) call CHKERR(1_mpiint, 'fillVal is not present but needs to be given here')
          select case(idim)
          case(1)
            tmp(1:sdim,:) = arr(1:sdim,:) !**
            tmp(sdim+1:N,:) = fillVal !**
          case(2)
            tmp(:,1:sdim) = arr(:,1:sdim) !**
            tmp(:,sdim+1:N) = fillVal !**
          end select
        endif
      endif
      call move_alloc(tmp, arr)
    end subroutine
    subroutine resize_arr_2d_r64(N, arr, dim, fillval, lrepeat)
      integer(iintegers), intent(in) :: N
      real(REAL64), allocatable, intent(inout) :: arr(:,:)
      integer(mpiint), intent(in), optional :: dim
      real(kind(arr)), intent(in), optional :: fillval
      logical, intent(in), optional :: lrepeat

      real(kind(arr)), allocatable :: tmp(:,:)
      integer(kind(N)) :: sdim, i, j
      integer(mpiint) :: idim
      logical :: repeat_dim

      idim = get_arg(1_mpiint, dim)
      if(idim.gt.size(shape(arr))) &
        call CHKERR(idim, 'requested resize dimension is larger than max dimension of inp array')
      sdim = size(arr, dim=idim)
      if(sdim.eq.N) return

      select case(idim)
      case(1)
        allocate(tmp(N,size(arr,dim=2))) !**
      case(2)
        allocate(tmp(size(arr,dim=1),N)) !**
      end select

      if(N.lt.sdim) then ! shrinking
        if(present(fillval)) call CHKERR(1_mpiint, 'resize_arr is about to shrink the input arr ' // &
          'but you provided a fillVal - this does not make sense')
        select case(idim)
        case(1)
          tmp(1:N,:) = arr(1:N,:) !**
        case(2)
          tmp(:,1:N) = arr(:,1:N) !**
        end select
      else
        repeat_dim = get_arg(.False., lrepeat)
        if(repeat_dim) then
          if(modulo(N,sdim).ne.0) &
            call CHKERR(1_mpiint, 'resize_arr cannot repeat the dimension('//itoa(idim)// &
            'because '//itoa(N)//' is does not a multiple of inp array size '//itoa(sdim))
          do i=1,N
            j = modulo(i-1,sdim)
            select case(idim)
            case(1)
              tmp(i,:) = arr(1+j,:) !**
            case(2)
              tmp(:,i) = arr(:,1+j) !**
            end select
          enddo
        else
          if(.not.present(fillVal)) call CHKERR(1_mpiint, 'fillVal is not present but needs to be given here')
          select case(idim)
          case(1)
            tmp(1:sdim,:) = arr(1:sdim,:) !**
            tmp(sdim+1:N,:) = fillVal !**
          case(2)
            tmp(:,1:sdim) = arr(:,1:sdim) !**
            tmp(:,sdim+1:N) = fillVal !**
          end select
        endif
      endif
      call move_alloc(tmp, arr)
    end subroutine
    subroutine resize_arr_1d_int32(N, arr, dim, fillval, lrepeat)
      integer(iintegers), intent(in) :: N
      integer(INT32), allocatable, intent(inout) :: arr(:)
      integer(mpiint), intent(in), optional :: dim
      integer(kind(arr)), intent(in), optional :: fillval
      logical, intent(in), optional :: lrepeat

      integer(kind(arr)), allocatable :: tmp(:)
      integer(kind(N)) :: sdim, i, j
      integer(mpiint) :: idim
      logical :: repeat_dim

      idim = get_arg(1_mpiint, dim)
      if(idim.gt.size(shape(arr))) &
        call CHKERR(idim, 'requested resize dimension is larger than max dimension of inp array')
      sdim = size(arr, dim=idim)
      if(sdim.eq.N) return

      allocate(tmp(N)) !**

      if(N.lt.sdim) then ! shrinking
        if(present(fillval)) call CHKERR(1_mpiint, 'resize_arr is about to shrink the input arr ' // &
          'but you provided a fillVal - this does not make sense')
        tmp(1:N) = arr(1:N) !**
      else
        repeat_dim = get_arg(.False., lrepeat)
        if(repeat_dim) then
          if(modulo(N,sdim).ne.0) &
            call CHKERR(1_mpiint, 'resize_arr cannot repeat the dimension('//itoa(idim)// &
            'because '//itoa(N)//' is does not a multiple of inp array size '//itoa(sdim))
          do i=1,N
            j = modulo(i-1,sdim)
            tmp(i) = arr(1+j) !**
          enddo
        else
          if(.not.present(fillVal)) call CHKERR(1_mpiint, 'fillVal is not present but needs to be given here')
          tmp(1:sdim) = arr(1:sdim) !**
          tmp(sdim+1:N) = fillVal !**
        endif
      endif
      call move_alloc(tmp, arr)
    end subroutine
    subroutine resize_arr_1d_int64(N, arr, dim, fillval, lrepeat)
      integer(iintegers), intent(in) :: N
      integer(INT64), allocatable, intent(inout) :: arr(:)
      integer(mpiint), intent(in), optional :: dim
      integer(kind(arr)), intent(in), optional :: fillval
      logical, intent(in), optional :: lrepeat

      integer(kind(arr)), allocatable :: tmp(:)
      integer(kind(N)) :: sdim, i, j
      integer(mpiint) :: idim
      logical :: repeat_dim

      idim = get_arg(1_mpiint, dim)
      if(idim.gt.size(shape(arr))) &
        call CHKERR(idim, 'requested resize dimension is larger than max dimension of inp array')
      sdim = size(arr, dim=idim)
      if(sdim.eq.N) return

      allocate(tmp(N)) !**

      if(N.lt.sdim) then ! shrinking
        if(present(fillval)) call CHKERR(1_mpiint, 'resize_arr is about to shrink the input arr ' // &
          'but you provided a fillVal - this does not make sense')
        tmp(1:N) = arr(1:N) !**
      else
        repeat_dim = get_arg(.False., lrepeat)
        if(repeat_dim) then
          if(modulo(N,sdim).ne.0) &
            call CHKERR(1_mpiint, 'resize_arr cannot repeat the dimension('//itoa(idim)// &
            'because '//itoa(N)//' is does not a multiple of inp array size '//itoa(sdim))
          do i=1,N
            j = modulo(i-1,sdim)
            tmp(i) = arr(1+j) !**
          enddo
        else
          if(.not.present(fillVal)) call CHKERR(1_mpiint, 'fillVal is not present but needs to be given here')
          tmp(1:sdim) = arr(1:sdim) !**
          tmp(sdim+1:N) = fillVal !**
        endif
      endif
      call move_alloc(tmp, arr)
    end subroutine

    elemental function deg2rad_r32(deg) result(r)
      real(REAL32) :: r
      real(REAL32),intent(in) :: deg
      r = deg * pi32 / 180_REAL32
    end function
    elemental function deg2rad_r64(deg) result(r)
      real(REAL64) :: r
      real(REAL64),intent(in) :: deg
      r = deg * pi64 / 180
    end function
    elemental function deg2rad_r128(deg) result(r)
      real(REAL128) :: r
      real(REAL128),intent(in) :: deg
      r = deg * pi128 / 180
    end function

    elemental function rad2deg_r32(rad) result(r)
      real(REAL32) :: r
      real(REAL32),intent(in) :: rad
      r = rad / pi32 * 180_REAL32
    end function
    elemental function rad2deg_r64(rad) result(r)
      real(REAL64) :: r
      real(REAL64),intent(in) :: rad
      r = rad / pi64 * 180
    end function
    elemental function rad2deg_r128(rad) result(r)
      real(REAL128) :: r
      real(REAL128),intent(in) :: rad
      r = rad / pi128 * 180
    end function

    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    pure function rmse_${dtype}$(a,b) result(rmse)
      real(${dtype}$) :: rmse(2)
      real(${dtype}$),intent(in) :: a(:),b(:)
      rmse(1) = sqrt( meanval( (a-b)**2 ) )
      rmse(2) = rmse(1)/max( meanval(b), epsilon(rmse) )
    end function
    #:endfor

#:for intype,dtype,otype in [ &
  ('integer', 'INT32' , 'ireals'), &
  ('integer', 'INT64' , 'ireals'), &
  ('real'   , 'REAL32', 'REAL32'), &
  ('real'   , 'REAL64', 'REAL64'), &
  ('real'   , 'REAL128','REAL128')]
#:for RANK in range(1, 8)
    pure function meanval_intype_${intype}$_${dtype}$_${RANK}$d_out${otype}$(arr) result(mean)
      ${intype}$(${dtype}$), intent(in) :: arr${ranksuffix(RANK)}$
      real(${otype}$) :: mean
      mean = real(sum(arr), kind=kind(mean)) / real(max(1,size(arr)), kind=kind(mean))
    end function
#:endfor
#:endfor

    elemental logical function approx_r128(a,b,precis) result(approx)
      real(REAL128),intent(in) :: a,b
      real(REAL128),intent(in),optional :: precis
      real(REAL128) :: factor
      if(present(precis) ) then
        factor = precis
      else
        factor = 10._REAL128*epsilon(b)
      endif
      if( a.lt.b-factor ) then
        approx = .False.
      elseif(a.gt.b+factor) then
        approx = .False.
      else
        approx = .True.
      endif
    end function
    elemental logical function approx_r64(a,b,precis) result(approx)
      real(REAL64),intent(in) :: a,b
      real(REAL64),intent(in),optional :: precis
      real(REAL64) :: factor
      if(present(precis) ) then
        factor = precis
      else
        factor = 10._REAL64*epsilon(b)
      endif
      if( a.lt.b-factor ) then
        approx = .False.
      elseif(a.gt.b+factor) then
        approx = .False.
      else
        approx = .True.
      endif
    end function
    elemental logical function approx_r32(a,b,precis) result(approx)
      real(REAL32),intent(in) :: a,b
      real(REAL32),intent(in),optional :: precis
      real(REAL32) :: factor
      if(present(precis) ) then
        factor = precis
      else
        factor = 10._REAL32*epsilon(b)
      endif
      if( a.le.b+factor .and. a.ge.b-factor ) then
        approx = .True.
      else
        approx = .False.
      endif
    end function
    elemental logical function rel_approx(a,b,precision)
      real(ireals),intent(in) :: a,b
      real(ireals),intent(in),optional :: precision
      real(ireals) :: factor,rel_error
      if(present(precision) ) then
        factor = precision
      else
        factor = 10*epsilon(b)
      endif
      rel_error = abs(a-b)/ max(tiny(a), abs(a+b)/2)

      if( rel_error .lt. precision ) then
        rel_approx = .True.
      else
        rel_approx = .False.
      endif
    end function

    function mpi_logical_and(comm,lval)
      integer(mpiint),intent(in) :: comm
      logical :: mpi_logical_and
      logical,intent(in) :: lval
      integer(mpiint) :: mpierr
      call mpi_allreduce(lval, mpi_logical_and, 1_mpiint, imp_logical, MPI_LAND, comm, mpierr); call CHKERR(mpierr)
    end function
    function mpi_logical_or(comm,lval)
      integer(mpiint),intent(in) :: comm
      logical :: mpi_logical_or
      logical,intent(in) :: lval
      integer(mpiint) :: mpierr
      call mpi_allreduce(lval, mpi_logical_or, 1_mpiint, imp_logical, MPI_LOR, comm, mpierr); call CHKERR(mpierr)
    end function

    function mpi_logical_all_same(comm,lval) result(lsame)
      integer(mpiint),intent(in) :: comm
      logical :: lsame !, land, lor
      logical,intent(in) :: lval
      integer(mpiint) :: i, isum, commsize, ierr
      ! Logical AND and OR version:
      !     land = mpi_logical_and(comm, lval)
      !     lor  = mpi_logical_or (comm, lval)
      !     lsame = land.eqv.lor
      ! however, it is better cast to it to int and do a sum reduction, otherwise we need 2 logical reductions
      call mpi_comm_size(comm, commsize, ierr); call CHKERR(ierr)
      if(commsize.gt.1_mpiint) then
        if(lval) then
          i = 1
        else
          i = 0
        endif
        call imp_allreduce_sum(comm, i, isum)
        if(lval) then
          lsame = isum.eq.commsize
        else
          lsame = isum.eq.0
        endif
      else
        lsame = .True.
      endif
    end function

    subroutine imp_allreduce_min_iintegers(comm,v,r)
      integer(mpiint),intent(in) :: comm
      integer(iintegers),intent(in) :: v
      integer(iintegers),intent(out) :: r
      integer(mpiint) :: mpierr
      call mpi_allreduce(v,r,1_mpiint,imp_iinteger, MPI_MIN, comm, mpierr); call CHKERR(mpierr)
    end subroutine
    subroutine imp_allreduce_min_ireals(comm,v,r)
      integer(mpiint),intent(in) :: comm
      real(ireals),intent(in) :: v
      real(ireals),intent(out) :: r
      integer(mpiint) :: mpierr
      call mpi_allreduce(v,r,1_mpiint,imp_ireals, MPI_MIN, comm, mpierr); call CHKERR(mpierr)
    end subroutine
    subroutine imp_allreduce_max_iintegers(comm,v,r)
      integer(mpiint),intent(in) :: comm
      integer(iintegers),intent(in) :: v
      integer(iintegers),intent(out) :: r
      integer(mpiint) :: mpierr
      call mpi_allreduce(v,r,1_mpiint,imp_iinteger, MPI_MAX, comm, mpierr); call CHKERR(mpierr)
    end subroutine
    subroutine imp_allreduce_max_ireals(comm,v,r)
      integer(mpiint),intent(in) :: comm
      real(ireals),intent(in) :: v
      real(ireals),intent(out) :: r
      integer(mpiint) :: mpierr
      call mpi_allreduce(v,r,1_mpiint,imp_ireals, MPI_MAX, comm, mpierr); call CHKERR(mpierr)
    end subroutine
    subroutine imp_allreduce_sum_ireals(comm,v,r)
      integer(mpiint),intent(in) :: comm
      real(ireals),intent(in) :: v
      real(ireals),intent(out) :: r
      integer(mpiint) :: mpierr
      call mpi_allreduce(v, r, 1_mpiint, imp_ireals, MPI_SUM, comm, mpierr); call CHKERR(mpierr)
    end subroutine
    subroutine imp_allreduce_sum_i32(comm,v,r)
      integer(mpiint),intent(in) :: comm
      integer(INT32),intent(in) :: v
      integer(INT32),intent(out) :: r
      integer(mpiint) :: mpierr
      call mpi_allreduce(v, r, 1_mpiint, imp_int4, MPI_SUM, comm, mpierr); call CHKERR(mpierr)
    end subroutine
    subroutine imp_allreduce_sum_i64(comm,v,r)
      integer(mpiint),intent(in) :: comm
      integer(INT64),intent(in) :: v
      integer(INT64),intent(out) :: r
      integer(mpiint) :: mpierr
      call mpi_allreduce(v, r, 1_mpiint, imp_int8, MPI_SUM, comm, mpierr); call CHKERR(mpierr)
    end subroutine


    subroutine imp_allreduce_mean_0d(comm,v,r)
      integer(mpiint),intent(in) :: comm
      real(ireals),intent(in) :: v
      real(ireals),intent(out) :: r
      integer(mpiint) :: numnodes, ierr
      call mpi_comm_size(comm, numnodes, ierr); call CHKERR(ierr)
      call imp_allreduce_sum(comm, v, r)
      r = r / real(numnodes, kind(r))
    end subroutine

#:for RANK in range(1, 4)
    subroutine imp_allreduce_mean_${RANK}$d(comm,v,r)
      integer(mpiint),intent(in) :: comm
      real(ireals),intent(in) :: v${ranksuffix(RANK)}$
      real(ireals),intent(out) :: r
      integer(INT64)  :: global_size
      real(ireals) :: my_avg

      call imp_allreduce_sum(comm, size(v, kind=INT64), global_size)
      my_avg = meanval(v) * size(v)
      call imp_allreduce_sum(comm, my_avg, r)
      r = r / real(global_size, kind(r))
    end subroutine
#:endfor

    subroutine imp_reduce_sum_r32(comm,v)
      real(REAL32),intent(inout) :: v
      integer(mpiint),intent(in) :: comm
      integer(mpiint) :: commsize, myid
      integer(mpiint) :: mpierr
      call MPI_Comm_size( comm, commsize, mpierr); call CHKERR(mpierr)
      if(commsize.le.1) return
      call MPI_Comm_rank( comm, myid, mpierr); call CHKERR(mpierr)

      if(myid.eq.0) then
        call mpi_reduce(MPI_IN_PLACE, v, 1_mpiint, imp_REAL32, MPI_SUM, 0_mpiint, comm, mpierr); call CHKERR(mpierr)
      else
        call mpi_reduce(v, MPI_IN_PLACE, 1_mpiint, imp_REAL32, MPI_SUM, 0_mpiint, comm, mpierr); call CHKERR(mpierr)
      endif
    end subroutine
    subroutine imp_reduce_sum_r64(comm,v)
      real(REAL64),intent(inout) :: v
      integer(mpiint),intent(in) :: comm
      integer(mpiint) :: commsize, myid
      integer(mpiint) :: mpierr
      call MPI_Comm_size( comm, commsize, mpierr); call CHKERR(mpierr)
      if(commsize.le.1) return
      call MPI_Comm_rank( comm, myid, mpierr); call CHKERR(mpierr)

      if(myid.eq.0) then
        call mpi_reduce(MPI_IN_PLACE, v, 1_mpiint, imp_REAL64, MPI_SUM, 0_mpiint, comm, mpierr); call CHKERR(mpierr)
      else
        call mpi_reduce(v, MPI_IN_PLACE, 1_mpiint, imp_REAL64, MPI_SUM, 0_mpiint, comm, mpierr); call CHKERR(mpierr)
      endif
    end subroutine
    subroutine imp_reduce_sum_r128(comm,v)
      ! sad hack for the moment because i have lots of problems with openmpi and quad prec reductions
      real(REAL128),intent(inout) :: v
      integer(mpiint),intent(in) :: comm
      real(REAL64) :: r
      integer(mpiint) :: ierr, commsize
      call MPI_Comm_size( comm, commsize, ierr); call CHKERR(ierr)
      if(commsize.le.1) return

      r = real(v, kind(r))
      call imp_reduce_sum(comm, r)
      v = real(r, kind(v))
    end subroutine

#:for method,dtype,mpitype,otype in [ &
  ('integer', 'INT32' , 'imp_int4'  , 'ireals'), &
  ('integer', 'INT64' , 'imp_int8'  , 'ireals'), &
  ('real'   , 'REAL32', 'imp_REAL32', 'REAL32'), &
  ('real'   , 'REAL64', 'imp_REAL64', 'REAL64')]
#:for RANK in range(1, 8)
    subroutine imp_reduce_mean_${method}$_${dtype}$_${RANK}$d_${otype}$(comm,v,r,root)
      integer(mpiint),intent(in) :: comm
      ${method}$(${dtype}$),intent(in) :: v${ranksuffix(RANK)}$
      real(${otype}$),intent(out) :: r
      integer(mpiint), intent(in), optional :: root

      real(${otype}$) :: my_avg
      integer(INT64)  :: global_size
      integer(mpiint) ::trgt, ierr, myid

      if(present(root)) then
        trgt = root
      else
        trgt = 0_mpiint
      endif

      my_avg = meanval(v) * size(v)
      call mpi_reduce(my_avg, r, 1_mpiint, ${mpitype}$, MPI_SUM, trgt, comm, ierr); call CHKERR(ierr)

      call mpi_reduce(size(v, kind=INT64), global_size, 1_mpiint, imp_int8, MPI_SUM, trgt, comm, ierr); call CHKERR(ierr)
      call mpi_comm_rank(comm, myid, ierr); call CHKERR(ierr)
      if(myid.eq.trgt) r = r / real(global_size, kind(r))
    end subroutine
#:endfor
#:endfor

#:for method,cast,dtype,mpitype,otype in [ &
  ('integer', 'int' , 'INT32' , 'imp_int4'  , 'ireals'), &
  ('integer', 'int' , 'INT64' , 'imp_int8'  , 'ireals'), &
  ('real'   , 'real', 'REAL32', 'imp_REAL32', 'REAL32'), &
  ('real'   , 'real', 'REAL64', 'imp_REAL64', 'REAL64')]
#:for RANK in range(0, 8)
    subroutine imp_min_mean_max_${method}$_${dtype}$_${RANK}$d_${otype}$(comm, arr, mmm)
      integer(mpiint), intent(in) :: comm
      ${method}$(${dtype}$), intent(in) :: arr${ranksuffix(RANK)}$
      real(${otype}$), intent(out) :: mmm(:)
#:if RANK==0
      mmm = real(arr, kind=${otype}$)
      if(.False.) then
        if(comm.lt.0) continue ! unused var
      endif
#:else
      ${method}$(${otype}$) :: vmin, vmax
      integer(mpiint) :: ierr

      vmin = ${cast}$(minval(arr), kind(vmin))
      vmax = ${cast}$(maxval(arr), kind(vmax))
      call mpi_reduce(vmin, mmm(1), 1_mpiint, ${mpitype}$, MPI_MIN, 0_mpiint, comm, ierr); call CHKERR(ierr)
      call imp_reduce_mean(comm, arr, mmm(2))
      call mpi_reduce(vmax, mmm(3), 1_mpiint, ${mpitype}$, MPI_MAX, 0_mpiint, comm, ierr); call CHKERR(ierr)
#:endif
    end subroutine
#:endfor
#:endfor

    subroutine imp_allgather_int_inplace(comm,v)
      integer(mpiint),intent(in) :: comm
      integer(iintegers),intent(inout) :: v(:)
      integer(mpiint) :: mpierr
      call mpi_allgather(MPI_IN_PLACE, 0_mpiint, MPI_DATATYPE_NULL, v, 1_mpiint, imp_iinteger, comm, mpierr); call CHKERR(mpierr)
    end subroutine

#:for method,dtype,mpitype in [ &
  ('logical', '', 'imp_logical'), &
  ('integer', 'INT32', 'imp_int4'), &
  ('integer', 'INT64', 'imp_int8'), &
  ('real', 'REAL32', 'imp_REAL32'), &
  ('real', 'REAL64', 'imp_REAL64')]
#:set dKIND = '' if method == 'logical' else '('+dtype+')'
#:for RANK in range(0, 8)
#:for modifier in [None, 'allocatable', 'pointer']
#:if (modifier is None and (RANK==0)) or (modifier is not None and (RANK>0))
    subroutine  imp_bcast_${method}$_${dtype}$_${RANK}$d_${modifier}$(comm,arr,sendid)
      integer(mpiint),intent(in) :: comm
      ${method}$ ${dKIND}$ #{if modifier}#,${modifier}$#{endif}#, intent(inout) :: arr${ranksuffix(RANK)}$
      integer(mpiint),intent(in) :: sendid
      integer(mpiint) :: commsize, ierr
#:if RANK > 0
      integer(mpiint) :: myid
      integer(iintegers) :: Ntot(${RANK}$)
#:endif
      call MPI_Comm_size( comm, commsize, ierr); call CHKERR(ierr)
      if(commsize.le.1) return

#:if RANK==0
      call mpi_bcast(arr,1_mpiint,${mpitype}$,sendid,comm,ierr); call CHKERR(ierr)
#:else
      call mpi_comm_rank( comm, myid, ierr); call chkerr(ierr)
      if(sendid.eq.myid) Ntot = shape(arr)

      call mpi_bcast(Ntot,${RANK}$_mpiint,imp_iinteger,sendid,comm,ierr); call CHKERR(ierr)

      if(myid.ne.sendid) then
#:if modifier == 'allocatable'
        if(allocated(arr)) then
          if(.not.all(shape(arr).eq.Ntot)) &
            call CHKERR(1_mpiint, 'Called a imp_bcast with an already allocated array on a receiving rank.'// &
            ' However, it has the wrong shape: send_array is shape '//itoa(Ntot)//' inp_arr is shape '//itoa(shape(arr)))
        else
          allocate( arr ${rankallocdims(RANK)}$ )
        endif
#:endif
#:if modifier == 'pointer'
        if(.not.associated(arr)) allocate( arr ${rankallocdims(RANK)}$ )
#:endif

        if(.not.all(shape(arr).eq.Ntot)) &
          call CHKERR(1_mpiint, 'Called a imp_bcast with an already allocated array on a receiving rank.'// &
          ' However, it has the wrong shape: send_array is shape '//itoa(Ntot)//' inp_arr is shape '//itoa(shape(arr)))
      endif
      call mpi_bcast(arr,size(arr),${mpitype}$,sendid,comm,ierr); call CHKERR(ierr)
#:endif
    end subroutine
#:endif
#:endfor
#:endfor
#:endfor

    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    elemental subroutine delta_scale_${dtype}$(kabs, ksca, g, opt_f, max_g)
      real(${dtype}$),intent(inout) :: kabs, ksca, g
      real(${dtype}$),intent(in), optional :: opt_f, max_g
      real(${dtype}$) :: dtau, w0, f

      if(present(opt_f)) then
        f = opt_f
      else
        f = g**2
      endif

      if(present(max_g)) then
        if(g.lt.max_g) return
        f = (max_g - g) / (max_g - 1._${dtype}$)
      endif

      dtau = kabs+ksca
      if(dtau.lt.epsilon(dtau)) return

      w0   = ksca/dtau
      g    = g

      call delta_scale_optprop( dtau, w0, g, f)

      kabs = dtau * (1._${dtype}$-w0)
      ksca = dtau * w0
    end subroutine
    #:endfor

    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    elemental subroutine delta_scale_optprop_${dtype}$(dtau, w0, g, f)
      real(${dtype}$), intent(inout) :: dtau,w0,g
      real(${dtype}$), intent(in) :: f

      if(g.ge.1._${dtype}$-epsilon(g)*10) then
        dtau = dtau * (1._${dtype}$ - w0)
        w0   = zero
        g    = zero
        return
      endif
      dtau = dtau * ( 1._${dtype}$ - w0 * f )
      g    = ( g - f ) / ( 1._${dtype}$ - f )
      w0   = w0 * ( 1._${dtype}$ - f ) / ( 1._${dtype}$ - f * w0 )
    end subroutine
    #:endfor

    function cumsum_ireals(arr) result(cumsum)
      real(ireals),intent(in) :: arr(:)
      real(ireals) :: cumsum(size(arr))
      integer :: i
      cumsum(1) = arr(1)
      do i=2,size(arr)
        cumsum(i) = cumsum(i-1) + arr(i)
      enddo
    end function
    function cumsum_iintegers(arr) result(cumsum)
      integer(iintegers),intent(in) :: arr(:)
      integer(iintegers) :: cumsum(size(arr))
      integer :: i
      cumsum(1) = arr(1)
      do i=2,size(arr)
        cumsum(i) = cumsum(i-1) + arr(i)
      enddo
    end function

    ! From Numerical Recipes: cumulative product on an array, with optional multiplicative seed.
    pure recursive function cumprod_ireals(arr,seed) result(ans)
      real(ireals), dimension(:), intent(in) :: arr
      real(ireals), optional, intent(in) :: seed
      real(ireals), dimension(size(arr)) :: ans
      integer(iintegers) :: n,j
      real(ireals) :: sd
      n=size(arr)
      if (n == 0) return
      sd = 1
      if (present(seed)) sd=seed
      ans(1)=arr(1)*sd
      if (n < npar_cumprod) then
        do j=2,n
          ans(j)=ans(j-1)*arr(j)
        end do
      else
        ans(2:n:2)=cumprod(arr(2:n:2)*arr(1:n-1:2),sd)
        ans(3:n:2)=ans(2:n-1:2)*arr(3:n:2)
      end if
    end function
    pure recursive function cumprod_i32(arr,seed) result(ans)
      integer(INT32), dimension(:), intent(in) :: arr
      integer(INT32), optional, intent(in) :: seed
      integer(INT32), dimension(size(arr)) :: ans
      integer(INT32) :: n,j
      integer(INT32) :: sd
      n=size(arr)
      if (n == 0) return
      sd = 1
      if (present(seed)) sd=seed
      ans(1)=arr(1)*sd
      if (n < npar_cumprod) then
        do j=2,n
          ans(j)=ans(j-1)*arr(j)
        end do
      else
        ans(2:n:2)=cumprod(arr(2:n:2)*arr(1:n-1:2),sd)
        ans(3:n:2)=ans(2:n-1:2)*arr(3:n:2)
      end if
    end function
    pure recursive function cumprod_i64(arr,seed) result(ans)
      integer(INT64), dimension(:), intent(in) :: arr
      integer(INT64), optional, intent(in) :: seed
      integer(INT64), dimension(size(arr)) :: ans
      integer(INT64) :: n,j
      integer(INT64) :: sd
      n=size(arr)
      if (n == 0) return
      sd = 1
      if (present(seed)) sd=seed
      ans(1)=arr(1)*sd
      if (n < npar_cumprod) then
        do j=2,n
          ans(j)=ans(j-1)*arr(j)
        end do
      else
        ans(2:n:2)=cumprod(arr(2:n:2)*arr(1:n-1:2),sd)
        ans(3:n:2)=ans(2:n-1:2)*arr(3:n:2)
      end if
    end function

    subroutine read_ascii_file_2d(filename, arr, ierr, skiplines, verbose)
      character(len=*),intent(in) :: filename
      integer(iintegers),intent(in),optional :: skiplines

      real(ireals),allocatable,intent(out) :: arr(:,:) ! shape nlines, ncolumns
      integer(mpiint), intent(out) :: ierr
      logical, intent(in), optional :: verbose

      real(ireals), allocatable :: line(:)
      character(len=2**14) :: line_str

      integer :: funit, io
      integer(iintegers) :: nlines, valid_lines, i, j, max_cols
      logical :: lverbose, file_exists

      ierr=0
      inquire(file=filename, exist=file_exists)

      lverbose = get_arg(.False., verbose)

      if(.not.file_exists) then
        if(lverbose) print *,'File ',trim(filename), 'does not exist!'
        ierr=1
        return
      endif

      open(newunit=funit, file=filename)
      if(present(skiplines)) then
        do i=1,skiplines
          read(funit,*)
        enddo
      endif

      print *,''
      nlines = 0
      valid_lines = 0
      max_cols = 0
      do
        read(funit, '(A)', iostat=io) line_str

        if(io.eq.0) then
          call split(line_str, line, ' ', ierr)

          if(ierr.eq.0)then
            valid_lines = valid_lines + 1
            if(max_cols.gt.1 .and. size(line).ne.max_cols) then
              ierr = 3
              if(lverbose) &
                call CHKWARN(ierr, 'Found a varying number of columns in the ascii file.. cannot read that')
              return
            endif
            max_cols = size(line)
          endif
          deallocate(line)

        elseif (io.lt.0) then ! end of file
          exit
        endif

        nlines = nlines + 1
      end do

      rewind(funit)
      if(present(skiplines)) then
        do i=1,skiplines
          read(funit,*)
        enddo
      endif

      allocate(line(max_cols))
      allocate(arr(valid_lines,max_cols))

      j = 1
      do i=1,nlines
        read(funit, *, iostat=io) line
        if(io.eq.0) then
          arr(j,:) = line
          j = j + 1
        endif
      end do

      close(funit)
      if(lverbose) print *,'I read '// &
        itoa(valid_lines)//' lines of ascii : '// &
        '('//itoa(nlines)//' total ) '// &
        'with '//itoa(max_cols)//' columns'

      contains
        subroutine split(str, a, sep, ierr)
          character(len=*), intent(in) :: str, sep
          real(ireals), intent(out), allocatable :: a(:)
          integer(mpiint), intent(out) :: ierr
          integer(iintegers) :: i,n
          logical :: last_char_was_sep
          last_char_was_sep = .True.
          n = 0
          do i=1,len(str)
            if( str(i:i) == sep) then
              if(.not.last_char_was_sep) n = n + 1
              last_char_was_sep = .True.
            else
              last_char_was_sep = .False.
            endif
          end do
          allocate (a(n))
          read(unit=str, fmt=*, iostat=ierr) a
        end subroutine
      end subroutine


    subroutine reorder_mpi_comm(icomm, Nrank_x, Nrank_y, new_comm)
      integer(mpiint), intent(in) :: icomm
      integer(mpiint), intent(out) :: new_comm
      integer(mpiint) :: Nrank_x, Nrank_y

      ! This is the code snippet from Petsc FAQ to change from PETSC (C) domain splitting to MPI(Fortran) domain splitting
      ! the numbers of processors per direction are (int) x_procs, y_procs, z_procs respectively
      ! (no parallelization in direction 'dir' means dir_procs = 1)

      integer(mpiint) :: x,y
      integer(mpiint) :: orig_id, petsc_id ! id according to fortran decomposition

      integer(mpiint) :: mpierr
      call MPI_COMM_RANK( icomm, orig_id, mpierr ); call CHKERR(mpierr)

      ! calculate coordinates of cpus in MPI ordering:
      x = int(orig_id) / Nrank_y
      y = modulo(orig_id ,Nrank_y)

      ! set new rank according to PETSc ordering:
      petsc_id = y*Nrank_x + x

      ! create communicator with new ranks according to PETSc ordering:
      call MPI_Comm_split(icomm, 1_mpiint, petsc_id, new_comm, mpierr)

      !print *,'Reordering communicator'
      !print *,'setup_petsc_comm: MPI_COMM_WORLD',orig_id,'calc_id',petsc_id
    end subroutine

    #:for dtype in ['REAL32', 'REAL64', 'REAL128']
    pure function compute_normal_3d_${dtype}$(p1,p2,p3) result(compute_normal_3d)
      ! for a triangle p1, p2, p3, if the vector U = p2 - p1 and the vector V = p3 - p1
      ! then the normal (right hand rotation)
      ! N = U X V and can be calculated by:
      real(${dtype}$), intent(in) :: p1(:), p2(:), p3(:)
      real(${dtype}$) :: compute_normal_3d(size(p1))
      real(${dtype}$) :: U(3), V(3)

      U = p2-p1
      V = p3-p1

      compute_normal_3d = cross_3d(U,V)

      compute_normal_3d = compute_normal_3d / norm2(compute_normal_3d)
    end function
    #:endfor

#:for dtype in ['REAL32', 'REAL64', 'REAL128']
    !> @brief return 1 if normal is pointing towards cell_center, -1 if its pointing away from it
    pure function determine_normal_direction_${dtype}$(normal, center_face, center_cell) result(d)
      real(${dtype}$), intent(in) :: normal(3), center_face(3), center_cell(3)
      integer(iintegers) :: d
      real(${dtype}$) :: dot
      dot = dot_product(normal, center_cell - center_face)
      d = int(sign(1._${dtype}$, dot), kind=kind(d))
    end function
#:endfor

    !> @brief reverse of spherical_2_cartesian
    !> @details theta == 0 :: z = -1, i.e. downward
    !> @details azimuth == 0 :: vector going toward minus y, i.e. sun shines from the north
    !> @details azimuth == 90 :: vector going toward minus x, i.e. sun shines from the east
#:for dtype in ['REAL32', 'REAL64', 'REAL128']
    subroutine cartesian_2_spherical_${dtype}$(sundir, phi, theta, ierr)
      real(${dtype}$), intent(in) :: sundir(3)
      real(${dtype}$), intent(out) :: phi, theta
      integer(mpiint), intent(out) :: ierr
      integer(mpiint) :: ierr_norm

      real(${dtype}$), parameter :: e_x(3) = [real(${dtype}$) :: 1, 0, 0]
      real(${dtype}$), parameter :: e_y(3) = [real(${dtype}$) :: 0, 1, 0]
      real(${dtype}$), parameter :: e_z(3) = [real(${dtype}$) :: 0, 0, 1]

      real(${dtype}$) :: sundir_normed(3), proj_sundir(3), az

      ierr = 0

      call normalize_vec(sundir, sundir_normed, ierr_norm); ! ignore norm error in case of sza==90
      theta = rad2deg(angle_between_two_normed_vec(sundir_normed, -e_z))

      proj_sundir = vec_proj_on_plane(sundir, -e_z)
      call normalize_vec(proj_sundir, ierr_norm); ! ignore norm error in case of sza==0

      az = angle_between_two_normed_vec(proj_sundir, -e_y)
      az = az * sign(1._${dtype}$, dot_product(proj_sundir, -e_x))

      phi = rad2deg(az)
    end subroutine
#:endfor

    !> @brief For local azimuth and zenith angles, return the local cartesian vectors phi azimuth, theta zenith angles, angles are input in degrees.
    !> @details theta == 0 :: z = -1, i.e. downward
    !> @details azimuth == 0 :: vector going toward minus y, i.e. sun shines from the north
    !> @details azimuth == 90 :: vector going toward minus x, i.e. sun shines from the east
#:for dtype in ['REAL32', 'REAL64', 'REAL128']
    pure function spherical_2_cartesian_${dtype}$(phi, theta, r) result(spherical_2_cartesian)
      real(${dtype}$), intent(in) :: phi, theta
      real(${dtype}$), intent(in), optional :: r
      real(${dtype}$) :: spherical_2_cartesian(3)

      spherical_2_cartesian(1) = -sin(deg2rad(theta)) * sin(deg2rad(phi))
      spherical_2_cartesian(2) = -sin(deg2rad(theta)) * cos(deg2rad(phi))
      spherical_2_cartesian(3) = -cos(deg2rad(theta))

      if(present(r)) spherical_2_cartesian = spherical_2_cartesian*r
    end function
#:endfor

#:for dtype in ['REAL32', 'REAL64', 'REAL128']
    pure subroutine normalize_vec_${dtype}$(vec, normed_vec, ierr)
      real(${dtype}$), intent(in) :: vec(:)
      real(kind(vec)), intent(out) :: normed_vec(:)
      integer(mpiint), intent(out) :: ierr
      real(kind(vec)) :: norm
      ierr = 0
      normed_vec = vec /  max(tiny(vec), maxval(abs(vec)))
      norm = norm2(normed_vec)
      if(norm.le.tiny(norm)) then
        ierr = 1
        norm = 1
      endif
      normed_vec = normed_vec/norm
    end subroutine
    pure subroutine normalize_vec_inplace_${dtype}$(vec, ierr)
      real(${dtype}$), intent(inout) :: vec(:)
      integer(mpiint), intent(out) :: ierr
      real(kind(vec)) :: norm
      ierr = 0
      vec = vec /  max(tiny(vec), maxval(abs(vec)))
      norm = norm2(vec)
      if(norm.le.tiny(norm)) then
        ierr = 1
        norm = 1
      endif
      vec = vec/norm
    end subroutine
#:endfor

    !> @brief returns the angle between two not necessarily normed vectors. Result is in radians
#:for dtype in ['REAL32', 'REAL64', 'REAL128']
    function angle_between_two_vec_${dtype}$(p1, p2) result(angle_between_two_vec)
      real(${dtype}$),intent(in) :: p1(:), p2(:)
      real(kind(p1)) :: angle_between_two_vec
      real(kind(p1)) :: np1(size(p1)), np2(size(p2))
      integer(mpiint) :: ierr
      call normalize_vec(p1, np1, ierr); call CHKERR(ierr, 'bad vec norm')
      call normalize_vec(p2, np2, ierr); call CHKERR(ierr, 'bad vec norm')
      angle_between_two_vec = angle_between_two_normed_vec(np1, np2)
    end function
#:endfor

#:for dtype in ['REAL32', 'REAL64', 'REAL128']
    function angle_between_two_normed_vec_${dtype}$(p1, p2) result(angle_between_two_vec)
      real(${dtype}$),intent(in) :: p1(:), p2(:)
      real(kind(p1)) :: angle_between_two_vec, dp
      real(kind(p1)), parameter :: eps = 1 + sqrt(epsilon(eps))
      if(all(approx(p1,p2))) then ! if p1 and p2 are the same, just return
        angle_between_two_vec = 0
        return
      endif
      dp = dot_product(p1, p2)
      if(dp.gt.eps.or.dp.lt.-eps) then
        call CHKWARN(1_mpiint, 'FPE exception angle_between_two_normed_vec :: dp wrong '//&
          & ftoa(dp)//' ('//ftoa(norm2(p1))//', '//ftoa(norm2(p2))//')')
      endif
      dp = max( min(dp, real(1, kind(dp))), real(-1, kind(dp)))
      angle_between_two_vec = acos(dp)
    end function
#:endfor

    !> @brief Determine Edge length/ distance between two points
#:for dtype in ['REAL32', 'REAL64']
    function distance_${dtype}$(p1,p2) result(distance)
      real(${dtype}$), intent(in) :: p1(:), p2(:)
      real(kind(p1)) :: distance
      integer(iintegers) :: i
      distance = 0
      do i=1,size(p1)
        distance = distance + (p2(i) - p1(i))**2
      enddo
      distance = sqrt(distance)
    end function
#:endfor

    !> @brief Use Herons Formula to determine the area of a triangle given the 3 edge lengths
#:for dtype in ['REAL32', 'REAL64']
    function triangle_area_by_edgelengths_${dtype}$(e1,e2,e3) result(triangle_area_by_edgelengths)
      real(${dtype}$), intent(in) :: e1,e2,e3
      real(${dtype}$) :: triangle_area_by_edgelengths
      real(${dtype}$) :: p
      p = (e1+e2+e3)/2
      triangle_area_by_edgelengths = sqrt(p*(p-e1)*(p-e2)*(p-e3))
    end function
#:endfor

    !> @brief Use Herons Formula to determine the area of a triangle given the 3 vertices
#:for dtype in ['REAL32', 'REAL64']
    function triangle_area_by_vertices_${dtype}$(v1,v2,v3) result(triangle_area_by_vertices)
      real(${dtype}$), intent(in) :: v1(:),v2(:),v3(:)
      real(${dtype}$) :: triangle_area_by_vertices
      real(${dtype}$) :: e1, e2, e3
      e1 = distance(v1,v2)
      e2 = distance(v2,v3)
      e3 = distance(v3,v1)
      triangle_area_by_vertices = triangle_area_by_edgelengths(e1,e2,e3)
    end function
#:endfor

    !> @brief compute the inner circle center of a triangle
#:for dtype in ['REAL32', 'REAL64']
    subroutine triangle_inner_circle_center_${dtype}$(p1, p2, p3, center)
      real(${dtype}$), dimension(:), intent(in) :: p1, p2, p3
      real(kind(p1)), dimension(:) :: center
      real(kind(p1)) :: e1, e2, e3
      e1 = distance(p2,p3)
      e2 = distance(p3,p1)
      e3 = distance(p1,p2)

      center = (e1*p1 + e2*p2 + e3*p3) / (e1+e2+e3)
    end subroutine
#:endfor

#:for dtype in ['REAL32', 'REAL64', 'REAL128']
    pure function distances_to_triangle_edges_${dtype}$(p1,p2,p3,p) result(distances_to_triangle_edges)
      real(${dtype}$), intent(in), dimension(2) :: p1,p2,p3, p
      real(${dtype}$) :: distances_to_triangle_edges(3)
      distances_to_triangle_edges(1) = distance_to_edge(p1,p2,p)
      distances_to_triangle_edges(2) = distance_to_edge(p2,p3,p)
      distances_to_triangle_edges(3) = distance_to_edge(p1,p3,p)
    end function
#:endfor

#:for dtype in ['REAL32', 'REAL64', 'REAL128']
    pure function distance_to_edge_${dtype}$(p1,p2,p) result(distance_to_edge)
      real(${dtype}$), intent(in), dimension(2) :: p1,p2, p
      real(${dtype}$) :: distance_to_edge

      distance_to_edge = abs( (p2(2)-p1(2))*p(1) - (p2(1)-p1(1))*p(2) + p2(1)*p1(2) - p2(2)*p1(1) ) / norm2(p2-p1)
    end function
#:endfor

#:for dtype in ['REAL32', 'REAL64', 'REAL128']
      !> @brief: rotate vector around given axis by angle [deg] with left hand rule
      pure function rotate_angle_x_${dtype}$(v,angle) result(rotated)
        real(${dtype}$) :: rotated(3)
        real(${dtype}$),intent(in) :: v(3), angle
        real(${dtype}$) :: M(3,3),s,c
        s=sin(deg2rad(angle))
        c=cos(deg2rad(angle))

        M(1,:)=[1._${dtype}$ ,0._${dtype}$ ,0._${dtype}$]
        M(2,:)=[0._${dtype}$, c   , s  ]
        M(3,:)=[0._${dtype}$,-s   , c  ]

        rotated = matmul(M,v)
      end function
      pure function rotate_angle_y_${dtype}$(v,angle) result(rotated)
        real(${dtype}$) :: rotated(3)
        real(${dtype}$),intent(in) :: v(3), angle
        real(${dtype}$) :: M(3,3),s,c
        s=sin(deg2rad(angle))
        c=cos(deg2rad(angle))

        M(1,:)=[c        , 0._${dtype}$, -s       ]
        M(2,:)=[0._${dtype}$, 1._${dtype}$, 0._${dtype}$]
        M(3,:)=[s        , 0._${dtype}$, c        ]

        rotated = matmul(M,v)
      end function
      pure function rotate_angle_z_${dtype}$(v,angle) result(rotated)
        real(${dtype}$) :: rotated(3)
        real(${dtype}$),intent(in) :: v(3), angle
        real(${dtype}$) :: M(3,3),s,c
        s=sin(deg2rad(angle))
        c=cos(deg2rad(angle))

        M(1,:)=[ c  , s   ,0._${dtype}$]
        M(2,:)=[-s  , c   ,0._${dtype}$]
        M(3,:)=[0._${dtype}$, 0._${dtype}$, 1._${dtype}$]

        rotated = matmul(M,v)
      end function
#:endfor

    ! https://en.wikipedia.org/wiki/Rotation_matrix#General_rotations
#:for dtype in ['REAL32', 'REAL64', 'REAL128']
    pure function rotation_matrix_around_axis_vec_${dtype}$(angle, rot_axis) result(M)
      ! left hand rule
      real(${dtype}$) :: M(3,3)
      real(${dtype}$),intent(in) :: angle, rot_axis(3)
      real(${dtype}$) :: s,c,u(3),omc
      if(norm2(rot_axis).lt.epsilon(rot_axis)) then ! cannot rotate into a zero vec
        M(:,1) = [1,0,0]
        M(:,2) = [0,1,0]
        M(:,3) = [0,0,1]
        return
      endif
      u = rot_axis / norm2(rot_axis)
      s=sin(angle)
      c=cos(angle)
      omc = 1._${dtype}$ - c

      M(1,:)=[u(1)*u(1)*omc + c     , u(1)*u(2)*omc - u(3)*s, u(1)*u(3)*omc + u(2)*s]
      M(2,:)=[u(2)*u(1)*omc + u(3)*s, u(2)*u(2)*omc + c     , u(2)*U(3)*omc - u(1)*s]
      M(3,:)=[u(3)*u(1)*omc - u(2)*s, u(3)*u(2)*omc + u(1)*s, u(3)*u(3)*omc + c     ]
    end function
#:endfor

    ! the resulting matrix will transform a vector from world coords into the given new coord system
    pure function rotation_matrix_world_to_local_basis(ex, ey, ez) result(M)
      real(ireals), dimension(3), intent(in) :: ex, ey, ez
      real(ireals), dimension(3), parameter :: kx=[1,0,0], ky=[0,1,0], kz=[0,0,1]
      real(ireals), dimension(3,3) :: M
      M(1,1) = dot_product(ex, kx)
      M(1,2) = dot_product(ex, ky)
      M(1,3) = dot_product(ex, kz)
      M(2,1) = dot_product(ey, kx)
      M(2,2) = dot_product(ey, ky)
      M(2,3) = dot_product(ey, kz)
      M(3,1) = dot_product(ez, kx)
      M(3,2) = dot_product(ez, ky)
      M(3,3) = dot_product(ez, kz)
    end function

    ! the resulting matrix will transform a vector from the given coord system into the world coordinate system
#:for dtype in ['REAL32', 'REAL64', 'REAL128']
    pure function rotation_matrix_local_basis_to_world_${dtype}$(ex, ey, ez) result(M)
      real(${dtype}$), dimension(3), intent(in) :: ex, ey, ez
      real(${dtype}$), dimension(3), parameter :: kx=[1,0,0], ky=[0,1,0], kz=[0,0,1]
      real(${dtype}$), dimension(3,3) :: M
      M(1,1) = dot_product(kx, ex)
      M(2,1) = dot_product(ky, ex)
      M(3,1) = dot_product(kz, ex)
      M(1,2) = dot_product(kx, ey)
      M(2,2) = dot_product(ky, ey)
      M(3,2) = dot_product(kz, ey)
      M(1,3) = dot_product(kx, ez)
      M(2,3) = dot_product(ky, ez)
      M(3,3) = dot_product(kz, ez)
    end function
#:endfor

    ! https://www.maplesoft.com/support/help/maple/view.aspx?path=MathApps%2FProjectionOfVectorOntoPlane
#:for dtype in ['REAL32', 'REAL64', 'REAL128']
    pure function vec_proj_on_plane_${dtype}$(v, plane_normal) result(vec_proj_on_plane)
      real(${dtype}$), dimension(3), intent(in) :: v, plane_normal
      real(${dtype}$) :: vec_proj_on_plane(3)
      vec_proj_on_plane = v - dot_product(v, plane_normal) * plane_normal  / norm2(plane_normal)**2
    end function
#:endfor

    pure function get_arg_logical(default_value, opt_arg) result(arg)
      logical :: arg
      logical, intent(in) :: default_value
      logical, intent(in), optional :: opt_arg
      if(present(opt_arg)) then
        arg = opt_arg
      else
        arg = default_value
      endif
    end function
    pure function get_arg_i32(default_value, opt_arg) result(arg)
      integer(INT32) :: arg
      integer(INT32), intent(in) :: default_value
      integer(INT32), intent(in), optional :: opt_arg
      if(present(opt_arg)) then
        arg = opt_arg
      else
        arg = default_value
      endif
    end function
    pure function get_arg_i64(default_value, opt_arg) result(arg)
      integer(INT64) :: arg
      integer(INT64), intent(in) :: default_value
      integer(INT64), intent(in), optional :: opt_arg
      if(present(opt_arg)) then
        arg = opt_arg
      else
        arg = default_value
      endif
    end function
    pure function get_arg_real32(default_value, opt_arg) result(arg)
      real(REAL32) :: arg
      real(REAL32), intent(in) :: default_value
      real(REAL32), intent(in), optional :: opt_arg
      if(present(opt_arg)) then
        arg = opt_arg
      else
        arg = default_value
      endif
    end function
    pure function get_arg_real64(default_value, opt_arg) result(arg)
      real(REAL64) :: arg
      real(REAL64), intent(in) :: default_value
      real(REAL64), intent(in), optional :: opt_arg
      if(present(opt_arg)) then
        arg = opt_arg
      else
        arg = default_value
      endif
    end function
    pure function get_arg_char(default_value, opt_arg) result(arg)
      character(len=default_str_len) :: arg
      character(len=*), intent(in) :: default_value
      character(len=*), intent(in), optional :: opt_arg
      if(present(opt_arg)) then
        arg = trim(opt_arg)
      else
        arg = trim(default_value)
      endif
    end function


    ! https://gist.github.com/t-nissie/479f0f16966925fa29ea
    recursive subroutine quicksort(a, first, last)
      integer(iintegers), intent(inout) :: a(:)
      integer(iintegers), intent(in) :: first, last
      integer(iintegers) :: i, j, x, t

      x = a( (first+last) / 2 )
      i = first
      j = last
      do
        do while (a(i) < x)
          i=i+1
        end do
        do while (x < a(j))
          j=j-1
        end do
        if (i >= j) exit
        t = a(i);  a(i) = a(j);  a(j) = t
        i=i+1
        j=j-1
      end do
      if (first < i-1) call quicksort(a, first, i-1)
      if (j+1 < last)  call quicksort(a, j+1, last)
    end subroutine quicksort

    ! https://stackoverflow.com/questions/44198212/a-fortran-equivalent-to-unique
    function unique(inp)
      !! usage sortedlist = unique(list)
      !! or reshape it first to 1D: sortedlist = unique(reshape(list, [size(list)]))
      integer(iintegers), intent(in) :: inp(:)
      integer(iintegers) :: list(size(inp))
      integer(iintegers), allocatable :: unique(:)
      integer(iintegers) :: n
      logical :: mask(size(inp))

      list = inp
      n=size(list)
      call quicksort(list, i1, n)

      ! cull duplicate indices
      mask = .False.
      mask(1:n-1) = list(1:n-1) == list(2:n)
      allocate(unique(count(.not.mask)))
      unique = pack(list, .not.mask)
    end function unique

    ! @brief: map from the flattened numbering to the coefficients in Ndims
    ! This is something like numpy.unravel
    ! offset could usually look like [1, size(arr, dim=1), size(arr, dim=1)*size(arr, dim=2), ...]
    pure subroutine ind_1d_to_nd(offsets, ind, nd_indices, cstyle)
      integer(iintegers), intent(in) :: offsets(:)
      integer(iintegers), intent(in) :: ind
      integer(iintegers), intent(out) :: nd_indices(size(offsets))
      logical, intent(in), optional :: cstyle
      integer(iintegers) :: k

      if(get_arg(.False., cstyle)) then
        k = ubound(nd_indices,1) ! last dimension
        nd_indices(k) = ind / offsets(k)

        do k=ubound(offsets,1)-1, lbound(offsets,1), -1
          nd_indices(k) = modulo(ind, offsets(k+1)) / offsets(k)
        enddo
      else
        k = ubound(nd_indices,1) ! last dimension
        nd_indices(k) = (ind-1) / offsets(k) +1

        do k=ubound(offsets,1)-1, lbound(offsets,1), -1
          nd_indices(k) = modulo(ind-1, offsets(k+1)) / offsets(k) +1
        enddo
      endif
    end subroutine

    ! @brief: map indices in N-dimensions to a flattened array
    ! This is something like numpy.ravel
    ! offset could usually look like [1, size(arr, dim=1), size(arr, dim=1)*size(arr, dim=2), ...]
    pure function ind_nd_to_1d(offsets, nd_indices, cstyle) result (i1d)
      integer(iintegers), intent(in) :: offsets(:)
      integer(iintegers), intent(in) :: nd_indices(:)
      logical, intent(in), optional :: cstyle
      integer(iintegers) :: i1d
      if(get_arg(.False., cstyle)) then
        i1d = dot_product(nd_indices(:), offsets)
      else
        i1d = dot_product(nd_indices(:)-1, offsets) +1
      endif
    end function

    pure subroutine ndarray_offsets(arrshape, offsets)
      integer(iintegers),intent(in) :: arrshape(:)
      integer(iintegers),intent(out) :: offsets(size(arrshape))
      offsets(1) = 1
      offsets(2:size(arrshape)) = arrshape(1:size(arrshape)-1)
      offsets = cumprod(offsets)
    end subroutine

    function get_mem_footprint(comm)
#include "petsc/finclude/petscsys.h"
      use petsc
      integer(mpiint),intent(in) :: comm
      real(ireals) :: get_mem_footprint
      PetscLogDouble :: memory_footprint
      integer(mpiint) :: ierr
      get_mem_footprint = zero

      call mpi_barrier(comm, ierr)
      call PetscMemoryGetCurrentUsage(memory_footprint, ierr); call CHKERR(ierr)

      get_mem_footprint = real(memory_footprint / 1024. / 1024. / 1024., ireals)

      !  if(ldebug) print *,myid,'Memory Footprint',memory_footprint, 'B', get_mem_footprint, 'G'
    end function

    function reverse_1d_real32(inp) result(rev)
      real(real32),intent(in) :: inp(:)
      real(real32) :: rev(size(inp,1))
      rev = inp(ubound(inp,1):lbound(inp,1):-1)
    end function
    function reverse_1d_real64(inp) result(rev)
      real(real64),intent(in) :: inp(:)
      real(real64) :: rev(size(inp,1))
      rev = inp(ubound(inp,1):lbound(inp,1):-1)
    end function
    function reverse_2d_real32(inp, dim) result(rev)
      real(real32),intent(in) :: inp(:,:)
      integer(iintegers), optional, intent(in) :: dim
      real(real32) :: rev(size(inp,1),size(inp,2))
      integer(iintegers) :: rdim
      rdim = get_arg(i1, dim)
      select case(rdim)
      case(1)
        rev = inp(ubound(inp,1):lbound(inp,1):-1, :)
      case(2)
        rev = inp(:, ubound(inp,2):lbound(inp,2):-1)
      case default
        call CHKERR(1_mpiint, 'dimension of reverse array does not fit input array')
      end select
    end function
    function reverse_2d_real64(inp, dim) result(rev)
      real(real64),intent(in) :: inp(:,:)
      integer(iintegers), optional, intent(in) :: dim
      real(real64) :: rev(size(inp,1),size(inp,2))
      integer(iintegers) :: rdim
      rdim = get_arg(i1, dim)
      select case(rdim)
      case(1)
        rev = inp(ubound(inp,1):lbound(inp,1):-1, :)
      case(2)
        rev = inp(:, ubound(inp,2):lbound(inp,2):-1)
      case default
        call CHKERR(1_mpiint, 'dimension of reverse array does not fit input array')
      end select
    end function
    function reverse_3d_real32(inp, dim) result(rev)
      real(real32),intent(in) :: inp(:,:,:)
      integer(iintegers), optional, intent(in) :: dim
      real(real32) :: rev(size(inp,1), size(inp,2), size(inp,3))
      integer(iintegers) :: rdim
      rdim = get_arg(i1, dim)
      select case(rdim)
      case(1)
        rev = inp(ubound(inp,rdim):lbound(inp,rdim):-1, :, :)
      case(2)
        rev = inp(:, ubound(inp,rdim):lbound(inp,rdim):-1, :)
      case(3)
        rev = inp(:, :, ubound(inp,rdim):lbound(inp,rdim):-1)
      case default
        call CHKERR(1_mpiint, 'dimension of reverse array does not fit input array')
      end select
    end function
    function reverse_3d_real64(inp, dim) result(rev)
      real(real64),intent(in) :: inp(:,:,:)
      integer(iintegers), optional, intent(in) :: dim
      real(real64) :: rev(size(inp,1), size(inp,2), size(inp,3))
      integer(iintegers) :: rdim
      rdim = get_arg(i1, dim)
      select case(rdim)
      case(1)
        rev = inp(ubound(inp,rdim):lbound(inp,rdim):-1, :, :)
      case(2)
        rev = inp(:, ubound(inp,rdim):lbound(inp,rdim):-1, :)
      case(3)
        rev = inp(:, :, ubound(inp,rdim):lbound(inp,rdim):-1)
      case default
        call CHKERR(1_mpiint, 'dimension of reverse array does not fit input array')
      end select
    end function
    function reverse_4d_real32(inp, dim) result(rev)
      real(real32),intent(in) :: inp(:,:,:,:)
      integer(iintegers), optional, intent(in) :: dim
      real(real32) :: rev(size(inp,1), size(inp,2), size(inp,3), size(inp,4))
      integer(iintegers) :: rdim
      rdim = get_arg(i1, dim)
      select case(rdim)
      case(1)
        rev = inp(ubound(inp,rdim):lbound(inp,rdim):-1, :, :, :)
      case(2)
        rev = inp(:, ubound(inp,rdim):lbound(inp,rdim):-1, :, :)
      case(3)
        rev = inp(:, :, ubound(inp,rdim):lbound(inp,rdim):-1, :)
      case(4)
        rev = inp(:, :, :, ubound(inp,rdim):lbound(inp,rdim):-1)
      case default
        call CHKERR(1_mpiint, 'dimension of reverse array does not fit input array')
      end select
    end function
    function reverse_4d_real64(inp, dim) result(rev)
      real(real64),intent(in) :: inp(:,:,:,:)
      integer(iintegers), optional, intent(in) :: dim
      real(real64) :: rev(size(inp,1), size(inp,2), size(inp,3), size(inp,4))
      integer(iintegers) :: rdim
      rdim = get_arg(i1, dim)
      select case(rdim)
      case(1)
        rev = inp(ubound(inp,rdim):lbound(inp,rdim):-1, :, :, :)
      case(2)
        rev = inp(:, ubound(inp,rdim):lbound(inp,rdim):-1, :, :)
      case(3)
        rev = inp(:, :, ubound(inp,rdim):lbound(inp,rdim):-1, :)
      case(4)
        rev = inp(:, :, :, ubound(inp,rdim):lbound(inp,rdim):-1)
      case default
        call CHKERR(1_mpiint, 'dimension of reverse array does not fit input array')
      end select
    end function

    function cstr(inp, color)
      character(len=*), intent(in) :: inp, color
      character(len=len(inp)+9) :: cstr
      cstr = achar(27)
      select case(color)
      case('dark grey')
        cstr = achar(27)//'[90m'
      case('black')
        cstr = achar(27)//'[30m'
      case('peach')
        cstr = achar(27)//'[91m'
      case('red')
        cstr = achar(27)//'[31m'
      case('light green')
        cstr = achar(27)//'[92m'
      case('green')
        cstr = achar(27)//'[32m'
      case('light yellow')
        cstr = achar(27)//'[93m'
      case('yellow')
        cstr = achar(27)//'[33m'
      case('light blue')
        cstr = achar(27)//'[94m'
      case('blue')
        cstr = achar(27)//'[34m'
      case('pink')
        cstr = achar(27)//'[95m'
      case('purple')
        cstr = achar(27)//'[35m'
      case('light aqua')
        cstr = achar(27)//'[96m'
      case('aqua')
        cstr = achar(27)//'[36m'
      case('pearl white')
        cstr = achar(27)//'[97m'

      case default
        call CHKERR(1_mpiint, 'dont know the color code for '//color)
      end select

      cstr = trim(cstr)//trim(inp)//achar(27)//'[0m'
    end function

    function char_arr_to_str(inp, deliminator) result(out_str)
      character(len=*), intent(in) :: inp(:)
      character(len=*), intent(in), optional :: deliminator
      character(:), allocatable :: out_str
      character(len=2),parameter :: default_delim=', '
      integer :: i

      if(size(inp).eq.0) then
        out_str=''
        return
      endif

      if(present(deliminator)) then
      out_str = trim(inp(1))
      do i = 2, size(inp)
        out_str = trim(out_str)//deliminator//trim(inp(i))
      enddo
    else
      out_str = trim(inp(1))
      do i = 2, size(inp)
        out_str = trim(out_str)//default_delim//trim(inp(i))
      enddo
    endif
    end function


! solve_quadratic equation ax2 + 2bx + c = 0
pure subroutine solve_quadratic_r32(a, b, c, x, ierr)
  real(kind=REAL32),intent(in) :: a,b,c
  real(kind=REAL32),dimension(2), intent(out) :: x
  integer(mpiint), intent(out) :: ierr

  real(kind=REAL32) :: q ,dis
  ierr = 0

  dis = b**2 - 4*a*c
  if (dis.lt.0) then
    ierr = 1
    return
  endif

  if(abs(b).lt.epsilon(b)) then
    q = sqrt(abs(c)/abs(a))
    x(:) = [q, -q]
  else
    if (b.ge.0) then
      q = -b - sqrt(dis)
    else
      q = -b + sqrt(dis)
    endif
    x(:) = [2*c/q, q/(2*a)]
  endif

  if(x(1).gt.x(2)) x = [x(2), x(1)]
end subroutine
pure subroutine solve_quadratic_r64(a, b, c, x, ierr)
  real(kind=REAL64),intent(in) :: a,b,c
  real(kind=REAL64),dimension(2), intent(out) :: x
  integer(mpiint), intent(out) :: ierr

  real(kind=REAL64) :: q ,dis
  ierr = 0

  dis = b**2 - 4*a*c
  if (dis.lt.0) then
    ierr = 1
    return
  endif

  if(abs(b).lt.epsilon(b)) then
    q = sqrt(abs(c)/abs(a))
    x(:) = [q, -q]
  else if (b.gt.0) then
    q = -b - sqrt(dis)
    x(:) = [q/(2*a), 2*c/q]
  else
    q = -b + sqrt(dis)
    x(:) = [2*c/q, q/(2*a)]
  endif

  if(x(1).gt.x(2)) x = [x(2), x(1)]
end subroutine
pure subroutine solve_quadratic_r128(a, b, c, x, ierr)
  real(kind=REAL128),intent(in) :: a,b,c
  real(kind=REAL128),dimension(2), intent(out) :: x
  integer(mpiint), intent(out) :: ierr

  real(kind=REAL128) :: q ,dis
  ierr = 0

  dis = b**2 - 4*a*c
  if (dis.lt.0) then
    ierr = 1
    return
  endif

  if(abs(b).lt.epsilon(b)) then
    q = sqrt(abs(c)/abs(a))
    x(:) = [q, -q]
  else if (b.gt.0) then
    q = -b - sqrt(dis)
    x(:) = [q/(2*a), 2*c/q]
  else
    q = -b + sqrt(dis)
    x(:) = [2*c/q, q/(2*a)]
  endif

  if(x(1).gt.x(2)) x = [x(2), x(1)]
end subroutine

! helper to sample a linspace
pure function linspace_r64(idx, rng, N) result(sample_pnt)
  integer(iintegers),intent(in) :: idx, N
  real(kind=REAL64),dimension(2), intent(in) :: rng
  real(kind=kind(rng)) :: sample_pnt
  if(N.gt.i1) then
    sample_pnt = rng(1) + (real(idx, kind(rng))-1) * ( rng(2)-rng(1) ) &
      / real(N-1, kind=kind(sample_pnt))
  else
    sample_pnt = rng(1)
  endif
end function
pure function linspace_r32(idx, rng, N) result(sample_pnt)
  integer(iintegers),intent(in) :: idx, N
  real(kind=REAL32),dimension(2), intent(in) :: rng
  real(kind=kind(rng)) :: sample_pnt
  if(N.gt.i1) then
    sample_pnt = rng(1) + (real(idx, kind(rng))-1) * ( rng(2)-rng(1) ) &
      / real(N-1, kind=kind(sample_pnt))
  else
    sample_pnt = rng(1)
  endif
end function


! determine if array is (strictly) monotoneous increasing/decreasing
#:for dtype in ['REAL32', 'REAL64', 'REAL128']
function assert_arr_is_monotonous_${dtype}$(arr, lincreasing, lstrict, lverbose) result(lis_linear)
  real(${dtype}$), intent(in) :: arr(:)
  logical, intent(in) :: lincreasing, lstrict
  logical, intent(in), optional :: lverbose
  logical :: lis_linear, is_verbose
  integer(iintegers) :: k
  is_verbose = get_arg(.False., lverbose)
  if(lincreasing) then
    if(lstrict) then
      do k=2,size(arr)
        if(arr(k).le.arr(k-1)) then
          lis_linear = .False.
          if(is_verbose) print *,'non monotonicity @ k='//toStr(k)
          return
        endif
      enddo
    else
      do k=2,size(arr)
        if(arr(k).lt.arr(k-1)) then
          lis_linear = .False.
          if(is_verbose) print *,'non monotonicity @ k='//toStr(k)
          return
        endif
      enddo
    endif
  else
    if(lstrict) then
      do k=2,size(arr)
        if(arr(k).ge.arr(k-1)) then
          lis_linear = .False.
          if(is_verbose) print *,'non monotonicity @ k='//toStr(k)
          return
        endif
      enddo
    else
      do k=2,size(arr)
        if(arr(k).gt.arr(k-1)) then
          lis_linear = .False.
          if(is_verbose) print *,'non monotonicity @ k='//toStr(k)
          return
        endif
      enddo
    endif
  endif
  lis_linear = .True.
end function
#:endfor

! Determine Domain Decomposition in 2D
subroutine domain_decompose_2d(comm, N_ranks_x, N_ranks_y, ierr)
  integer(mpiint), intent(in) :: comm
  integer(mpiint), intent(out) :: N_ranks_x, N_ranks_y
  integer(mpiint), intent(out) :: ierr

  integer(mpiint) :: numnodes, j

  call mpi_comm_size(comm, numnodes, ierr); call CHKERR(ierr)

  N_ranks_y = ceiling(sqrt(1.*numnodes))
  do j = 1, N_ranks_y
    if(modulo(numnodes, j).eq.0) then
      N_ranks_y = j
      N_ranks_x = numnodes / N_ranks_y
      ierr = 0
    endif
  enddo

  if(N_ranks_y*N_ranks_x .ne. numnodes) then
    ierr = 1
  endif
end subroutine

! Determine Domain Decomposition in 2D with the help of Petsc DMDA
subroutine domain_decompose_2d_petsc(comm, &
    & Nx_global, Ny_global, &
    & Nx_local, Ny_local, &
    & xStart, yStart, &
    & nxproc, nyproc, ierr)
  integer(mpiint), intent(in) :: comm
  integer(iintegers), intent(in) :: Nx_global, Ny_global
  integer(iintegers), intent(out) :: Nx_local, Ny_local
  integer(iintegers), intent(out) :: xStart, yStart
  integer(iintegers), allocatable, intent(inout) :: nxproc(:), nyproc(:)
  integer(mpiint), intent(out) :: ierr

  type(tDM) :: dm
  integer(iintegers) :: Nranksx, Nranksy
  integer(iintegers) :: z, p

  call DMDACreate2d(comm, &
    & DM_BOUNDARY_PERIODIC, DM_BOUNDARY_PERIODIC,&
    & DMDA_STENCIL_STAR, &
    & Nx_global, Ny_global, &
    & PETSC_DECIDE, PETSC_DECIDE, &
    & i1, i1, PETSC_NULL_INTEGER, PETSC_NULL_INTEGER, dm, ierr); call CHKERR(ierr)
  call DMSetup(dm, ierr); call CHKERR(ierr)

  call DMDAGetInfo(dm, PETSC_NULL_INTEGER, &
    & PETSC_NULL_INTEGER, PETSC_NULL_INTEGER, PETSC_NULL_INTEGER, &
    & Nranksx, Nranksy, PETSC_NULL_INTEGER, &
    & PETSC_NULL_INTEGER, PETSC_NULL_INTEGER, &
    & PETSC_NULL_INTEGER, PETSC_NULL_INTEGER, PETSC_NULL_INTEGER, &
    & PETSC_NULL_INTEGER, ierr); call CHKERR(ierr)

  call DMDAGetCorners(dm, xStart, yStart, z, Nx_local, Ny_local, p, ierr); call CHKERR(ierr)

  allocate(nxproc(Nranksx))
  allocate(nyproc(Nranksy))
  call DMDAGetOwnershipRanges(dm, nxproc, nyproc, PETSC_NULL_INTEGER, ierr); call CHKERR(ierr)
  call DMDestroy(dm, ierr); call CHKERR(ierr)
end subroutine


#:for basetype,dtype,destructor,optdef in [ &
  ('type'      , 'tVec'   , 'call VecDestroy(obj, ierr)   ; call CHKERR(ierr);', 'integer(mpiint) :: ierr'), &
  ('type'      , 'tDM'    , 'call DMDestroy (obj, ierr)   ; call CHKERR(ierr);', 'integer(mpiint) :: ierr'), &
  ('type'      , 'tKSP'   , 'call KSPDestroy(obj, ierr)   ; call CHKERR(ierr);', 'integer(mpiint) :: ierr'), &
  ('type'      , 'tMat'   , 'call MatDestroy(obj, ierr)   ; call CHKERR(ierr);', 'integer(mpiint) :: ierr'), &
  ('type'      , 'tIS'    , 'call ISDestroy (obj, ierr)   ; call CHKERR(ierr);', 'integer(mpiint) :: ierr'), &
  ('logical'   , None     , None                                            , None), &
  ('integer'   , 'INT32'  , None                                            , None), &
  ('integer'   , 'INT64'  , None                                            , None), &
  ('real'      , 'REAL32' , None                                            , None), &
  ('real'      , 'REAL64' , None                                            , None)]
#:set dKIND = '' if dtype == None else '('+dtype+')'
#:for RANK in range(0, 8)
#:if not (destructor is not None and (RANK>0))
    subroutine  deallocate_allocatable_${basetype}$_${dtype}$_${RANK}$d(obj)
      ${basetype}$ ${dKIND}$, allocatable, intent(inout) :: obj${ranksuffix(RANK)}$
      ${optdef}$
      if(allocated(obj)) then
        ${destructor}$
        deallocate(obj)
      endif
    end subroutine
#:endif
#:endfor
#:endfor

  subroutine char_to_lower(str)
    character(len=*), intent(inout) :: str
    integer :: i
    do i = 1, len(str)
      select case(str(i:i))
      case("A":"Z")
        str(i:i) = achar(iachar(str(i:i))+32)
      end select
    end do
  end subroutine

  subroutine char_to_upper(str)
    character(len=*), intent(inout) :: str
    integer(iintegers) :: i
    do i = 1, len(str)
      select case(str(i:i))
      case("a":"z")
        str(i:i) = achar(iachar(str(i:i))-32)
      end select
    end do
  end subroutine

#:for dtype in ['REAL32', 'REAL64', 'REAL128']
#:for RANK in range(0, 8)
  function colored_str_by_range${dtype}$_${RANK}$d(inp, limits, colors) result (res)
    real(${dtype}$), intent(in) :: inp${ranksuffix(RANK)}$
    real(${dtype}$), intent(in) :: limits(:)
    character(len=*), intent(in) :: colors(:)
    character(:), allocatable :: res

    integer(iintegers) :: icolor
    #:if RANK>0
    integer(iintegers) :: i
    ${basetype}$(${dtype}$), allocatable :: inp1d(:)
    #:endif

    call CHKERR(size(colors,kind=mpiint)-size(limits, kind=mpiint)+1_mpiint, &
      & " size of inputs are not as expected:"// &
      & " colors should be one less than limits"// &
      & " but have "//itoa(size(colors))//" "//itoa(size(limits)))

    #:if RANK==0

    ! default is no color
    res = toStr(inp)

    do icolor = 1, size(colors)
      if(is_inrange(inp, limits(icolor), limits(icolor+1))) then
        res = cstr( toStr(inp), colors(icolor) )
      endif
    enddo

    #:else

    inp1d = pack(inp, .True.)
    res = ''

    entryloop: do i=1,size(inp1d)
      do icolor = 1, size(colors)
        if(is_inrange(inp1d(i), limits(icolor), limits(icolor+1))) then
          res = res // cstr( toStr(inp1d(i)), colors(icolor) )
          cycle entryloop
        endif
      enddo
      res = res // toStr(inp1d(i))
    enddo entryloop
    #:endif

  end function
#:endfor
#:endfor

end module
